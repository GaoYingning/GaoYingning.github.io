[{"title":"let和const命令","date":"2020-07-28T11:06:22.000Z","path":"2020/07/28/let和const命令/","text":"es6let与var的差异let 允许声明一个在作用域限制在块级中的变量、语句或者表达式 块级作用域 var 声明的变量只能是全局或整个函数块的 let 不能重复声明 let 不会被预解析 const 常量常量不能重新赋值 不能重复声明 块级作用域 const 不会被预解析let 和 const命令 12345678910111213141516171819202122232425262728293031323334353637for(var i=0;i&lt;5;i++)&#123; ...&#125;console.log(i)//4for(let i=0;i&lt;5;i++)&#123; ...&#125;console.log(i)//i is not definedvar a=[];for(var i=0;i&lt;10;i++)&#123; a[i]=function()&#123; console.log(i); &#125;;&#125;a[6](); //10//var 声明的变量在全局范围都有效，循环内被赋给数组a的函数内部的console.log(i),里面的i指向的就是全局的i。//所有数组a的成员里面的i，指向的都是同一个i，所以最后输出的都是10var a=[];for(let i=0;i&lt;10;i++)&#123; a[i]=function()&#123; console.log(i) &#125;;&#125;a[6]();//6//let声明的变量，当前的i只在本轮循环有效，每次循环i都是一个新的变量，最后输出6.//js引擎内部会记住上一轮循环的值，初始化本轮的变量i时，就在上一轮循环基础上进行计算for(let i=0;i&lt;3;i++)&#123; let i='abc'; console.log(i);&#125;//abc//abc//abc//for循环的特别之处，是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域//内部变量i和循环变量i不在同一个作用域 不存在变量提升12345console.log(foo) //undefinedvar foo=2;console.log(bar) //报错referenceErrorlet bar=2; 暂时性死区es6规定，在区块内存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。在let声明变量之前，都属于变量的死区，只要使用该变量就报错。 只要块级作用域内存在let命令，它所声明的变量就绑定这个区域，不受外部影响 12345678910111213141516171819var temp=123;if(true)&#123; temp=\"abc\";//ReferenceError let temp;&#125;//-----------------typeof x;//报错let x;//-------------//若变量根本没声明，使用typeof不会报错typeof udeclared_variable //\"undefined\"//-----------------function bar(x=y,y=2)&#123; return [x,y];&#125;bar();//报错，因为给x赋值y的时候，y还没有声明//-----------------var x=x;//不报错let x=x;//报错 块级作用域12345678var tmp=new Date();function f()&#123; console.log(tmp); if(false)&#123; var tmp=\"hello world\"; &#125;&#125;f();//undefined if代码块的外部使用外层的tmp变量，内层使用内存tmp变量，但函数f执行后，由于变量提升，导致内层tmp覆盖了外层的tmp变量 es6的块级作用域12345678function f1()&#123; let n=5; if(true)&#123; //块级作用域 let n=10; &#125; console.log(n) //5&#125; 块级作用域的出现，使得匿名立即执行函数表达式不再必要了 块级作用域与函数声明es5规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明 123456789if(true)&#123; function f()&#123;&#125;&#125;//----------try&#123; function f()&#123;&#125;&#125;catch(e)&#123;&#125; 以上两种函数声明，根据es5规定都是非法的。但是，浏览器没有遵守这个规定，为了兼容以前的代码，还是支持在块级作用域中声明函数，所以上面两种情况可以运行 es6引入了块级作用域，明确允许在块级作用域中声明函数。块级作用域中，函数声明语句的行为类似let，在块级作用域外不可引用 12345678910//es6环境function f()&#123;console.log(\"i am outside\")&#125;(function()&#123; if(false)&#123; //重复声明一次函数f function f()&#123;console.log(\"i am inside\")&#125; &#125; f();&#125;)();//es6浏览器理论是会得到i am outside，但是会报错， es6浏览器规定：允许在块级作用域内声明函数，函数声明类似于var，即会提升到全局作用域或函数作用域的头部，函数声明还会提升到所在的块级作用域的头部 考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句 1234567891011121314&#123; //块级作用域内部的函数声明语句，建议不要使用 let a=\"secret\"; function f()&#123; return a; &#125;&#125;&#123; //块级作用域内部，优先使用函数表达式 let a=\"secret\"; let f=function()&#123; return a; &#125;&#125; es6的块级作用域必须有大括号 12if(true) let x=1;//报错if(true)&#123;let x=1;&#125;//不报错 函数声明也是如此，严格模式下，函数只能声明在当前作用域的顶层。 const命令const一旦声明，就必须立即初始化，不能之后在赋值。const作用域与let相同：只在声明所在的块级作用域内有效const常量 不提示，存在暂时性死区，不可重复声明 12var mes=\"hello\";const mes=\"bye\";//报错 const只能保证变量指向的地址是固定的，至于它指向的数据结构是不可控制的。 123456const foo=&#123;&#125;;//为foo添加属性可以成功foo.prop=123;foo.prop;//123//将foo指向另一个对象就会报错foo=&#123;&#125;//foo is read-only 对象冻结Object.freeze 1234const foo=Object.freeze(&#123;&#125;);//常规模式下，下面一行不起作用，//严格模式下，会报错foo.prop=123; 对象彻底冻结 12345678var constantize=(obj)=&gt;&#123; Object.freeze(obj); Object.keys(obj).forEach((key,i)=&gt;&#123; if(typeof obj[key]=='object')&#123; constantize(obj[key]); &#125; &#125;);&#125;; es6声明变量6种方法：var、function、let、const、import、class 顶层对象的属性es5顶层对象的属性与全局变量是等价的。这会出现几个问题，首先是没法在编译时就报出变量未声明的错误，只有运行时才能知道。顶层对象的属性是到处可以读写的，这非常不利于模块化编程。顶层对象是一个有实体含义的对象，不合适。var、function声明的全局变量，依旧属于顶层对象的属性es6开始let、const、class声明的全局变量，不属于顶层对象的属性，全局变量将逐步与顶层对象的属性脱钩。","tags":[{"name":"es6","slug":"es6","permalink":"http://yoursite.com/tags/es6/"}]},{"title":"函数表达式","date":"2020-07-28T08:14:39.000Z","path":"2020/07/28/函数表达式/","text":"函数表达式定义函数的方式：函数声明，函数表达式函数声明提升：在执行代码前会先读取函数声明。所以函数声明可以放在调用它的语句后面 函数表达式语法形式： 123var functionName=function(arg0,arg1,arg2)&#123; //函数体&#125;; 这种情况创建的函数叫匿名函数，因为function关键字后面没有标识符(匿名函数有时候也叫拉姆达函数)。 函数表达式与普通表达式一样，使用前必须先赋值。 1234sayHi();//错误，函数不存在var sayHi=function()&#123; console.log(\"hi\");&#125; 理解函数提升的关键，就是理解函数声明与函数表达式之间的区别 1234567891011121314//var sayHi;if(condition)&#123; function sayHi()&#123; console.log(\"hi\"); &#125;&#125;else&#123; function sayHi()&#123; console.log(\"yo\"); &#125;&#125;//表面上看，以上代码在condition为true时，执行第一个sayhi定义，否则，使用另一个定义。实际上，这在ECMAScript属于无效语法//大多数浏览器都会返回第二个声明，忽略condition，firefox会在condition为true时返回第一个声明// 可以在代码前面加上sayHi的声明,不同的函数会根据condition被赋值给sayHi 递归1234567891011function factorial(num)&#123; if(num&lt;1)&#123; return 1; &#125;else&#123; return num*factorial(num-1); &#125;&#125;//这是一个经典的递归阶乘函数var anotherFactorial=factorial;factorial=null;console.log(anotherFactorial(4)) //出错 由于将factorial置为空，在执行anotherfactorial递归的时候，factorial不是函数，所以报错 arguments.callee是一个指向正在执行的函数的指针， 1234567function factorial(num)&#123; if(num&lt;=1)&#123; return 1; &#125;else&#123; return num*arguments.callee(num-1);//arguments.callee替代函数名，不会出错 &#125;&#125; 但严格模式下，不能通过脚本访问arguments.callee，访问这个属性会导致错误。可以使用命名函数表达式来达成相同效果 1234567var factorial=(function f(num)&#123; if(num&lt;=1)&#123; return 1; &#125;else&#123; return num*f(num-1); &#125;&#125;); 以上代码创建了一个名为f()的命名函数表达式，将它赋值给变量factorial。即使把函数赋值给另一个变量，函数的名字f仍然有效。 闭包闭包是指有权访问另一个函数作用域中的变量的函数。创建闭包的常用方式，就是在一个函数内部创建另一个函数。 12345678910111213function createComparisonFunction(propertyName)&#123; return function(object1,object2)&#123; var value1=object1[propertyName]; var value2=object2[propertyName]; if(value1&lt;value2)&#123; return -1; &#125;else if(value1&gt;value2)&#123; return 1; &#125;else&#123; return 0; &#125; &#125;;&#125; 返回的内部函数(匿名函数)，访问了外部函数的变量propertyName。即使该内部函数返回了，而且是在其他地方被调用了，它仍可访问变量propertyName。因为内部函数的作用域链中包含外部函数的作用域。 如何创建作用域链以及作用域链有什么作用的细节，对彻底理解闭包至关重要当某个函数被调用时，会创建一个执行环境及相应的作用域链。然后，使用arguments和其他命名参数的值来初始化函数的活动对象。但在作用域链中，外部函数的活动对象始终处于第二位……直至作为作用域链终点的全局执行环境。 在函数执行过程中，为读取和写入变量的值，就需要在作用域链中查询变量 12345678910function compare(value1,value2)&#123; if(value1&lt;value2)&#123; return -1; &#125;else if(value1&gt;value2)&#123; return 1; &#125;else&#123; return 0; &#125;&#125;var result=compare(5,10); 先定义了compare()函数，然后又在全局作用域中调用了它。调用compare()时，会创建一个包含arguments、value1和value2的活动对象。全局执行环境的变量对象(包含result和compare)，在compare()执行环境的作用域链中则处于第二位。后台的每个执行环境都有一个表示变量的对象—变量对象。全局环境的变量对象始终存在，而像compare()函数这样的局部环境的变量对象，则只在函数执行的过程中存在。在创建compare()函数时，会创建一个预先包含全局变量对象的作用域链，这个作用域链被保存在内部的[[Scope]]属性中。当调用compare()函数时，会为函数创建一个执行环境，然后通过复制函数的[[Scope]]属性中的对象构建起执行环境的作用域链。此后，又有一个活动对象(在此作为变量对象使用)被创建并被推入执行环境作用域链的前端。对于这个例子中compare()函数的执行环境而言，其作用域链中包含两个变量对象：本地活动对象和全局变量对象。显然，作用域链本质上是一个指向变量对象的指针列表，它只引用但不实际包含变量对象 在另一个函数内部定义的函数会将包含函数(即外部函数)的活动对象添加到它的作用域链中。即在createComparisonFunction()函数内部定义的匿名函数在作用域链中，实际上将会包含外部函数createComparisonFunction()的活动对象。 12var compare=createComparisonFunction(\"name\");var result=compare(&#123;name:\"nich\"&#125;,&#123;name:\"greg\"&#125;); 在匿名函数从createComparisonFunction()中被返回后，它的作用域链被初始化为包含createComparisonFunction()函数的活动对象和全局变量对象。匿名函数就可以访问在createComparisonFunction()中定义的所有变量。 闭包与变量作用域链的这种配置机制引出了一个值得注意的副作用，即闭包只能取得包含函数中任何变量的最后一个值。闭包所保存的是整个变量对象，而不是某个特殊的变量 123456789function createFunctions()&#123; var result=new Array(); for(var i=0;i&lt;10;i++)&#123; result[i]=function()&#123; return i; &#125;; &#125; return result;&#125; 返回一个函数数组，每个函数都返回10 因为每个函数的作用域链中都保存着createFunctions()函数的活动对象，所以它们引用的都是同一个变量i可以通过另一个匿名函数强制让闭包行为符合预期 1234567891011function createFunctions()&#123; var result=new Array(); for(var i=0;i&lt;10;i++)&#123; result[i]=function(num)&#123; return funtion()&#123; return num; &#125;; &#125;(i); &#125; return result;&#125; 重写了createFunctions()函数后，每个函数就会返回不同的索引值。没有直接吧闭包赋值给数组，而是定义了一个匿名函数，并将立即执行该匿名函数的结果赋给数组。这个匿名函数有一个参数num，也就是最终的函数要返回的值。在调用每个匿名函数时，我们传入了变量i。函数参数是按值传递的，所以就会将变量i的当前值复制给参数num。在这个匿名函数内部，又创建了一个访问num的闭包。最后，result数组中的每个函数都有自己num变量的一个副本 关于this对象this对象是在运行时基于函数的执行环境绑定的：在全局函数中，this等于window，而当作函数被作为某个对象的方法调用时，this等于那个对象。匿名函数的执行环境具有全局性，因此this对象通常指向windows。 12345678910var name=\"the window\";var object=&#123; name:\"my object\", getNameFunc:function()&#123; return function()&#123; return this.name; &#125;; &#125;&#125;;console.log(object.getNameFunc()()); //the window 在严格模式下 Object.getNameFunc()返回的是一个匿名函数，返回一个字符串，然后匿名函数调用this.name，在全局作用域执行，就为the window 每个函数在被调用时都会自动取得两个特殊变量:this和arguments。内部函数在搜索这两个变量时，只会搜索到其活动对象为止，因此永远不可能直接访问外部函数中的这两个变量。 把外部作用域中的this对象保存在一个闭包能够访问到的变量里，就可以让闭包访问该对象 1234567891011var name=\"the window\"var object=&#123; name:\"my object\", getNameFunc:function()&#123; var that =this; return function()&#123; return that.name; &#125;; &#125;&#125;;console.log(object.getNameFunc()()) //my object 定义匿名函数前，把this对象赋值给一个名叫that的对象，在定义闭包后，闭包可以访问这个变量，因为它是我们在包含函数中特意声明的一个变量。即使在函数返回后，that仍然引用着object，所以调用object.getNameFunc()()就返回了”my object”this和arguments的问题是一样的 几种特殊情况 1234567891011var name=\"the window\"var object=&#123; name: \"my object\", getName:function()&#123; return this.name; &#125;&#125;;object.getName(); //my object(object.getName)(); //my object(object.getName=object.getName)();//the window ,在非严格模式下 第一行代码跟平常一样调用了object.getName()，返回的是my object，因为this.name就是object.name;第二行代码在调用这个方法前先加上了括号，虽然加上括号后，就好像只是在引用一个函数，但this的值得到了维持，因为object.getName和(object.getName)的定义是相同的。第三行代码先执行了一条赋值语句，然后在调用赋值后的结果，因为这个赋值表达式的值是函数本身，所以this的值不能得到维持，结果返回了the window 内存泄漏如果闭包的作用域链中保存着一个html元素，那么就意味着该元素将无法被销毁 123456function assignHandler()&#123; var element=document.getElementById(\"someElement\"); element.onclick=function()&#123; console.log(element.id); &#125;;&#125; 代码创建了一个作为element元素事件处理程序的闭包，而这个闭包又创建了一个循环引用。由于匿名函数保存了一个对assignHandler()的活动对象的引用，因此就会导致无法减少element的引用数。只要匿名函数在，element的引用次数至少是1，所以它所占用的内存永远不会被回收。 12345678function assignHandler()&#123; var element=document.getElementById(\"someElement\"); var id=element.id; element.onclick=function()&#123; console.log(id); &#125; element=null;&#125; 闭包会引用包含函数的整个活动对象，而其中包含着element。即使闭包不能直接引用element，包含函数的活动对象中也仍然会保存一个引用。所以有必要把element变量设置为null，这样就能解除对DOM对象的引用，减少引用次数，确保正常回收占用的内存。 模仿块级作用域js没有块级作用域。匿名函数可以用来模仿块级作用域，用作块级作用域(通常称为私有作用域)的匿名函数的语法如下 123(function()&#123; //这里是块级作用域&#125;)(); 以上代码定义并立即调用了一个匿名函数，将函数声明在一对圆括号中，表示它实际上是一个函数表达式。而其后的另一对圆括号会立即调用这个函数。函数声明后面不能跟圆括号 12345678function outputNumbers(count)&#123; (function()&#123; for(var i=0;i&lt;count;i++)&#123; console.log(i); &#125; &#125;)(); alert(i) //导致错误&#125; 私有变量严格来说，js没有私有成员的概念，所有对象属性都是公有的。任何函数中定义的变量，都可以认为是私有变量，因为不能在函数的外部访问这些变量私有变量包括函数的参数、局部变量和在函数内部定义的其他函数 1234function add(num1,num2)&#123; var sum=num1+num2; return num;&#125; 这个函数内部有三个私有变量：num1、num2和sum。在函数内部可以访问这几个变量，但在函数外部则不能访问它们。我们可以在函数内部创建一个闭包，闭包可以通过自己的作用域链也可以访问这些变量，利用这一点，就可以创建用于访问私有变量的公有方法。有权访问私有变量和私有函数的公有方法称为特权方法。有两种在对象上创建特权方法的方式第一种是构造函数种定义,基本模式如下 12345678910111213function MyObject()&#123; //私有变量和私有函数 var privateVariable=10; function privateFunction()&#123; return false; &#125; //特权方法 this.publicMethod=function()&#123; privateVariable++; return privateFunction(); &#125;;&#125;//只有通过publicMethod()这一个途径访问privateVariable和privateFunction 这个模式在构造函数内部定义了所有私有变量和函数，然后，又继续创建了能够访问这些私有成员的特权方法。能够在构造函数中定义特权方法，是因为特权方法作为闭包有权访问在构造函数中定义的所有变量和函数。 构造函数模式的缺点是针对每个实例都会创建同样一组新方法，而使用静态私有变量来实现特权方法可以避免这个问题 静态私有变量通过在私有作用域中定义私有变量或函数，同样也可以创建特权方法，模式如下 1234567891011121314151617(function()&#123; //私有变量和私有函数 var privateVariable=10; function privateFunction()&#123; return false; &#125; //构造函数 //函数声明只能创建局部函数，初始化未经声明的变量，总是会创建一个全局变量，所以myobjec是全局变量 //但在严格模式下给未经声明的变量赋值会导致错误 MyObject=function()&#123; &#125;; //公有/特权方法 MyObject.prototype.publicMethod=function()&#123; privateVariable++; return privateFunction(); &#125;;&#125;)() 这个模式与在构造函数中定义特权方法的主要区别，就在于私有变量和函数是由实例共享的。由于特权方法是在原型上定义的，因此所有实例都使用同一个函数。而这个特权方法，作为一个闭包，总是保存着对包含作用域的引用 12345678910111213141516171819(function()&#123; var name=\"\"; Person=function(value)&#123; name=value; &#125;; Person.prototype.getName=function()&#123; return name; &#125;; Person.prototype.setName=function(value)&#123; name=value; &#125;&#125;)();var p1=new Person(\"nich\");p1.getName()//\"nich\"p1.setName(\"greg\")//\"greg\"var p2=new Person(\"mic\")p1.getName();//\"mic\"p2.getName();//\"mic\" 这种模式下，变量name会变成一个静态的、由所有实例共享的属性。以这种方式创建静态私有变量会因为使用原型而增进代码复用，但每个实例都没有自己的私有变量。 模块模式前面的模式是用于为自定义类型创建私有变量和特权方法的。模块模式则是为单例创建私有变量和特权方法。单例就是只有一个实例的对象，js是按照对象字面量的方式来创建单例对象的 模块语法通过为单例添加私有变量和特权方法能够使其得到增强 123456789101112131415var singleton=function()&#123;//私有变量和私有函数var privateVariable=10;function privateFunction()&#123; return false;&#125;//特权/公有方法和属性return&#123; publicProperty:true, publicMethod:function()&#123; privateVariable++; return privateFunction(); &#125;&#125;;&#125;(); 增强的模块模式返回对象之前加入对其增强的代码，这种增强的模块模式适合那些单例必须是某种类型的实例，同时还必须添加某些属性或方法对其加以增强的情况 12345678910111213141516var singleton=function()&#123; //私有变量和私有函数 var privateVariable=10; function privateFunction()&#123; return false; &#125; //创建对象 var object=new CustomType(); //添加特权/公有属性和方法 object.publicMethod=function()&#123; privateVariable++; return privateFunction(); &#125;; //返回这个对象 return object;&#125;();","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"},{"name":"js高级程序设计","slug":"js高级程序设计","permalink":"http://yoursite.com/tags/js%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"每日算法02","date":"2020-07-27T07:10:39.000Z","path":"2020/07/27/每日算法02/","text":"机器人的运动范围地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？ 思路：从起点坐标(0,0)开始移动，每成功走过一个格子，就把该位置值设为1，然后从当前位置开始上、下、左、右进行移动，返回四个方向移动值之和并加1。 12345678910111213141516171819202122232425262728 public int movingCount(int threshold,int rows,int cols)&#123; //初始化一个m行n列的标志数组 int flag[][]=new int[rows][cols]; //以(0,0)位置开始移动 return helper(0,0,rows,cols,flag,threshold);&#125;public int helper(int i,int j,int rows,int cols,int [][]flag,int threshold)&#123; //如果当前位置不在矩阵内，即i&lt;0或j&lt;0或i&gt;=rows或j&gt;=cols，即当前位置不可到达。 //若当前位置坐标不满足条件即numSum(i)和大于限定值，即当前位置不可到达。 //若当前位置已经被访问过，即flag标志为1，则该位置不可再次到达。 if (i&lt;0||j&lt;0||i&gt;=rows||j&gt;=cols||numSum(i)+numSum(j)&gt;threshold||flag[i][j]==1)&#123; return 0; &#125; flag[i][j]=1; return helper(i-1,j,rows,cols,flag,threshold)+ helper(i+1,j,rows,cols,flag,threshold)+ helper(i,j-1,rows,cols,flag,threshold)+ helper(i,j+1,rows,cols,flag,threshold)+1;&#125;public int numSum(int i)&#123; //计算单个坐标值的累加和 int sum=0; do&#123; sum+=i%10; &#125;while ((i=i/10)&gt;0); return sum;&#125; 矩阵中的路径请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。 例如a b c es f c sa d e e矩阵中包含一条字符串”bcced”的路径，但是矩阵中不包含”abcb”路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。 123456789101112131415161718192021222324252627282930313233343536373839//给定的输入矩阵matrix是一个一维数组 public boolean hasPath(char[] matrix,int rows,int cols,char[] str)&#123; //标志位，初始化为false boolean[] flag=new boolean[matrix.length]; for (int i=0;i&lt;rows;i++)&#123; for (int j=0;j&lt;cols;j++)&#123; //先找到一个与str字符串第一个元素匹配的矩阵元素 if(judge(matrix,i,j,rows,cols,flag,str,0))&#123; return true; &#125; &#125; &#125; return false;&#125;//judge(初始矩阵，行坐标i，纵坐标j，矩阵行数，矩阵列数，待判断的字符串，字符串索引初始为0即先判断字符串的第一位)public boolean judge(char[] matrix,int i,int j,int rows,int cols,boolean[]flag,char[]str,int k)&#123; //先根据i和j计算匹配的第一个元素转为一维数组的位置 int index=i*cols+j; //若当前坐标不在矩阵内 //若当前索引值与字符串对应位置值不同 //若当前位置已经走过，都表示当前路不通。 if(i&lt;0||j&lt;0||i&gt;=rows||j&gt;=cols||matrix[index]!=str[k]||flag[index]==true)&#123; return false; &#125; //若k等于str.length-1，说明已经匹配成功，返回true if(k==str.length-1)&#123; return true; &#125; //给当前位置置为true，说明已经走到了 flag[index]=true; //然后上、下、左、右寻找下一个位置 if(judge(matrix,i-1,j,rows,cols,flag,str,k+1)||judge(matrix,i+1,j,rows,cols,flag,str,k+1)|| judge(matrix,i,j-1,rows,cols,flag,str,k+1)||judge(matrix,i,j+1,rows,cols,flag,str,k+1))&#123; return true; &#125; //走到这，说明这一条路不通，还原，再试其他的路径 flag[index]=false; return false;&#125;","tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"数组","slug":"数组","permalink":"http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"},{"name":"回溯","slug":"回溯","permalink":"http://yoursite.com/tags/%E5%9B%9E%E6%BA%AF/"}]},{"title":"基本包装类型","date":"2020-07-27T06:59:00.000Z","path":"2020/07/27/基本包装类型/","text":"基本包装类型引用类型与基本包装类型的主要区别就是对象的生存期。使用new操作符创建的引用类型的实例，在执行流离开当前作用域之前都一直保存在内存中。 而自动创建的基本包装类型的对象，则只存在于一行代码的执行瞬间，然后立即被销毁。这意味着我们不能在运行时为基本类型添加属性和方法 123var s1=\"some text\";s1.color=\"red\";console.log(s1)//undefined 注意，使用new调用基本包装类型的构造函数，与直接调用同名的转型函数是不一样的。12345678var value=\"25\"var number=Number(value) //转型函数console.log(typeof number) //\"number\"var obj=new Number(value) //构造函数console.log(typeof obj) //\"object\"//上述中，变量number中保存的是基本类型值25，而变量obj中保存的是Number的实例。 Boolean类型布尔表达式中的所有对象都会被转换为true。 123456var falseObject=new Boolean(false);var falseValue=false;console.log(typeof falseObect) //Objectconsole.log(typeof falseValue) //booleanconsole.log(falseObject instanceof Boolean) //trueconsole.log(falseValue instanceof Boolean) //fasle Number类型Number类型提供了一些用于将数值格式化为字符串的方法toFixed()方法会按照指定的小数位返回数值的字符串表示，如 12345var num=10console.log(num.toFixed(2));//\"10.00\"var num=10.005;console.log(num.toFixed(2))//\"10.01\" toExponential()方法返回以指数表示法（也称e表示法），表示的数值的字符串形式 12var num=10console.log(num.toExponential(1)) //\"1.0e+1\" toPrecision()可以表示某个数值的最合适的格式，该方法会返回固定大小（fixed）格式，也可能返回指数形式 1234var num=99console.log(num.toPrecision(1))//\"1e+2\"console.log(num.toPrecision(2))//\"99\"console.log(num.toPrecision(3))//\"99.0\" String类型length属性，即使字符串中包含双字节字符（不是占一个字节的ascii字符），每个字符也仍然算一个字符 字符方法charAt():以单字符字符串的形式返回给定位置的那个字符charCodeAt()：返回给定位置上的字符的字符编码 ECMAScript5还定义了另一个访问个别字符的方法，在支持此方法的浏览器中，可以使用方括号加数字索引来访问字符串中的特定字符 字符串操作方法concat():用于将一个或多个字符串拼接起来，返回拼接得到的新字符串，可以接受任意多个参数，在实践中使用更多的还是加号操作符(+)slice()、substr()、substring()这三个方法都返回被操作字符串的一个子字符串，都接受一或两个参数。第一个参数指定子字符串的开始位置，第二个位置（在指定情况下）表示子字符串到哪里结束。slice()和substring()的第二个参数指定的是子字符串最后一个字符后面的位置。substr()的第二个参数指定的是返回的字符个数。如果没有给这些方法传递第二个参数，则将字符串的长度作为结束位置。 在传递给这些方法的参数为负数时slice方法将传入负值与字符串长度相加，substr方法将负的第一个参数加上字符串的长度，而将第二个参数转换为0substring方法会把所有负值参数都转换为0 1234567var stringValue=\"hello world\";console.log(stringValue.slice(-3)) //\"rld\"console.log(stringValue.substring(-3)) //\"hello world\"console.log(stringValue.substr(-3)) //\"rld\"console.log(stringValue.slice(3,-4)) //\"lo w\"console.log(stringValue.substring(3,-4));//\"hel\"console.log(stringValue.substr(3,-4)) //\"\"（空字符串) 当第二个参数是负值时，slice()方法会把第二个参数转换为7substring()方法会把第二个参数转换为0，使调用变为substring(3,0),而这个方法会将较小的数作为开始位置，将大的值作为结束位置substr()将第二个参数转换为0，意味着返回包含零个字符的字符串，即空字符串。 字符串位置方法indexOf()从字符串开头向后搜索子字符串，返回子字符串的位置，没找到，返回-1lastIndexOf()从字符串的末尾向前搜索子字符串，返回子字符串的位置这两个方法可以接收可选的第二个参数，表示从字符串中的哪个位置开始搜索indexOf从该参数指定的位置向后搜索，忽略该位置之前的所有字符lastIndexOf从指定的位置向前搜索，忽略该位置之后的所有字符 123var stringValue=\"hello world\"console.log(stringValue.indexOf(\"o\",6)) //7console.log(stringValue.lastIndexOf(\"o\",6)) //4 trim()方法该方法创建一个字符串的副本，删除前置及后缀的所有空格，然后返回结果trimLeft()删除字符串开头的空格trimRight()删除字符串末尾的空格 字符串大小写转换方法toLowerCase()、toUpperCase()toLocaleLowerCase()、toLocaleUpperCase()方法针对特定地区的实现。 字符串的模式匹配方法match():在字符串上调用这个方法，本质上与调用RegExp的exec()方法相同。match只接受一个参数，要么是正则表达式，要么是一个RegExp对象 123456789var text=\"cat, bat, sat, fat\";var pattern=/.at/;//与pattern.exec(text)相同var matches=text.match(pattern);console.log(matches.index);//0console.log(matches[0]); //\"cat\" 只有保存第一项，没有捕获组 matches[1]=undefinedconsole.log(pattern.lastIndex);//0console.log(text.search(pattern)) //1 search():与match方法参数相同，由字符串或RegExp对象指定一个正则表达式。search()返回字符串中第一个匹配项的索引，若没有，返回-1，search从字符串开头向后查找模式 replace()方法，接受两个参数，第一个参数可以是一个RegExp对象或者一个字符串（这个字符串不会被转换成正则表达式）第二个参数可以是一个字符串或者一个函数。如果第一个参数是字符串，只会替换第一个子字符串。要想替换所有子字符串，只有用正则表达式并指定全局（g）标志 若第二个参数是字符串，可以使用一些特殊的字符序列，将正则表达式操作得到的值插入到结果字符串中 1234567字符序列 替换文本$$ $$&amp; 匹配整个模式的子字符串。与RegExp.lastMatch的值相同$&#39; 匹配的子字符串之前的子字符串。与RegExp.leftContext的值相同$&#96; 匹配的子字符串之后的子字符串。与RegExp.rightContext的值相同$n 匹配第n个捕获组的子字符串，其中n等于0-9。$1是匹配的第一个捕获组的子字符串，若正则表达式没定义捕获组，则为空字符串$nn 匹配第nn个捕获组的子字符串，其中nn等于01-99 123var text=\"cat, bat, sat, fat\";result=text.replace(/(.at)/g,\"word ($1)\");console.log(result) //word (cat), word (bat), word (sat), word (fat) replace()第二个参数是一个函数 12345678910111213141516function htmlEscape(text)&#123; return text.replace(/[&lt;&gt;\"&amp;]/g,function(match,pos,originalText)&#123; switch(match)&#123; case \"&lt;\": return \"&amp;lt;\"; case \"&gt;\": return \"&amp;gt;\"; case \"&amp;\": return \"&amp;amp;\"; case \"\\\"\": return \"&amp;quot;\"; &#125; &#125;);&#125;console.log(htmlEscape(\"&lt;p class=\\\"greeting\\\"&gt;Hello world!&lt;/p&gt;\"));//&amp;lt;p class=&amp;quot;greeting&amp;quot;&amp;gt;Hello world!&amp;lt;/p&amp;gt; split():该方法基于指定的分隔符将一个字符串分割成多个子字符串，并将结果放在一个数组中。分隔符可以是字符串，也可以是一个RegExp对象(这个方法不会将字符串看成正则表达式)split可以接受可选的第二个参数，用于指定数组的大小，以确保返回的数组不会超过既定大小 1234var colorText=\"red,blue,green,yellow\";var colors1=colorText.split(\",\"); //[\"red\",\"blue\",\"green\",\"yellow\"]var colors2=colorText.split(\",\",2): //[\"red\",\"blue\"]var colors3=colorText.split(/[^\\,]+/) //以不是逗号分隔数组 //[\"\",\",\",\",\",\",\",\"\"] localeCompare方法该方法比较两个字符串，并返回下列值中一个1、字符串在字母表中排在参数前 ，返回负数，大多数为-12、字符串等于参数，返回03、字符串在字母表中排在参数后，返回整数，大多数为1var s=”yellow”s.localeCompare(“brick”)//1s.localeCompare(“zoo”) //-1 fromCharCode()方法与charCodeAt()执行的是相反的操作","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"},{"name":"js高级程序设计","slug":"js高级程序设计","permalink":"http://yoursite.com/tags/js%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"Fucntion类型","date":"2020-07-27T06:43:48.000Z","path":"2020/07/27/Fucntion类型/","text":"函数声明与函数表达式解析器在向执行环境中加载数据时，对函数声明和函数表达式并非一视同仁。 解析器会率先读取函数声明，并使其在执行任何代码之前可用（可用访问）至于函数表达式，则必须等到解析器执行到它所在的代码行，才会真正被解释执行。 1234alert(sum(10,10))function sum(num1,num2)&#123; return num1+num2;&#125; 在代码开始执行之前，解析器就已经通过一个函数声明提升（function declaration hoisting）的过程，读取并将函数声明添加到执行环境中。js引擎在第一遍会声明函数并将它们放到源代码树的顶部。所以，即使声明函数的代码在调用它的代码后面，js引擎也会把函数声明提升到顶部。但函数表达式不会进行函数声明提升 函数内部属性函数内部包含两个对象：arguments和thisarguments主要用途是保存函数参数，这个对象还有一个callee属性，该属性是一个指针，指向拥有这个arguments对象的函数 123456789101112131415function factorial(num)&#123; if(num&lt;1)&#123; return 1; &#125;else&#123; return num*factorial(num-1); &#125;&#125;//这个函数的执行和函数名紧紧耦合在一起了，为了消除这种耦合现象，可用使用arguments.calleefunction factorial(num)&#123; if(num&lt;1)&#123; return 1; &#125;else&#123; return num*arguments.callee(num-1); &#125;&#125; this引用的是函数据以执行的环境对象函数的名字仅仅是一个包含指针的变量而已。 ECMAScript5规范化了另一个函数对象的属性：caller，属性中保存着调用当前函数的函数的引用，若全局作用域调用当前函数，它为null 当函数在严格模式下，访问arguments.callee会导致错误，访问arguments.caller也会出错，在非严格模式下 arguments.caller始终是undefined。定义这个属性是为了区分arguments.caller和caller属性。严格模式下，不能为函数的caller属性赋值，否则会导致错误。 每个函数都包含两个非继承而来的方法：apply()和call()都是在特定的作用域中调用函数，实际上等于设置函数体内this对象的值。apply方法接收两个参数，一个是在其中运行的作用域，另一个是参数数组。其中，第二个参数可用是Array实例，也可用是arguments对象。 12345678function sum(num1,num2)&#123; return num1+num2;&#125;function callSum1(num1,num2)&#123; return sum.apply(this,arguments) &#125;console.log(callSum1(10,10))//20//callSum1在执行sum时传入this作为this值（因为是在全局作用域中调用的，所以传入的就是window对象）和argumets对象 在严格模式下，未指定环境对象而调用函数，则this值不会转型为window。除非明确把函数添加到某个对象或者调用apply()或call()，否则this值将是undefined call()方法和apply()方法作用相同，区别仅在于接收参数的方式不同。call()第一个参数是this，其他参数直接传递给函数，传递给函数的参数必须逐个列举出来。 1234567function sum(num1,num2)&#123; return num1+num2;&#125;function callSum(num1,num2)&#123; return sum.call(this,num1,num2);&#125;console.log(callSum(10,10)); //20 apply()和call()真正的作用在于扩充函数执行的作用域123456789window.color=\"red\";var o=&#123;color:\"blue\"&#125;;function sayColor()&#123; console.log(this.color);&#125;sayColor();//redsayColor.call(this)//redsayColor.call(window)//redsayColor.call(o);//blue 使用call()和apply()扩充作用域最大好处是对象不需要与方法有任何耦合关系。 bind()函数，这个方法会创建一个函数的实例，其this值会被绑定到传给bind()函数的值1234567window.color=\"red\";var o=&#123;color:\"blue\"&#125;;function sayColor()&#123; console.log(this.color);&#125;var objectSayColor=sayColor.bind(o);objectSayColor();//blue","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"},{"name":"js高级程序设计","slug":"js高级程序设计","permalink":"http://yoursite.com/tags/js%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"继承","date":"2020-07-27T00:35:46.000Z","path":"2020/07/27/继承/","text":"ECMAScript实现继承主要是依赖原型链。 原型链基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。 假如让原型对象等于另一个类型的实例，此时原型对象就会包含一个指向另一个原型的指针，另一个原型中也会包含一个指向另一个构造函数的指针，层层递进。这就是原型链的基本概念 基本模式 1234567891011121314151617function SuperType()&#123; this.property=true;&#125;SuperType.prototype.getSuperValue=function()&#123; return this.property;&#125;;function SubType()&#123; this.subproperty=false;&#125;//继承了SuperTypeSubType.prototype=new SuperType();SubType.prototype.getSubValue=function()&#123; return this.subproperty;&#125;;var instance=new SubType();console.log(instance.getSuperValue()); //true 在上面代码中，我们将SubType的原型替换为了新原型即SuperType的实例。新原型不仅具有作为一个SuperType的实例所拥有的全部属性和方法，其内部还有一个指针，指向了SuperType的原型最终结果为：instance指向SubType的原型，SubType的原型又指向SuperType的原型。GetSuperValue方法仍然在SuperType.prototype中，但property则位于SubType.prototype中，因为property是一个实例属性，而GetSuperValue是一个原型方法SubType.prototype现在是SuperType的实例，那么property就位于该实例中。instance.constructor现在指向SuperType，因为原来的SubType.prototype中的constructor被重写了，实际上不是重写，而是指向了SuperType的原型，而这个原型对象constructor属性指向SuperType 通过实现原型链，本质上扩展了原型搜索机制 默认的原型所有的原型默认都继承了Object，而这个继承也是通过原型链实现的。 SubType继承了SuperType，而SuperType继承了Object。 确定原型和实例的关系instanceof操作符：只要用这个操作符来测试实例与原型链中出现过的构造函数，结果就为true 1console.log(instance instanceof SuperType) //true isPrototypeOf()方法：同样只要原型链出现过的原型，都可以说是该原型链派生的实例的原型，该方法会返回true。 1console.log(Object.prototype.isPrototypeOf(instance)); //true 谨慎定义方法子类型有时候需要重写父类中的方法，或添加某些方法。但给原型添加方法的代码一定要放在替换原型的语句之后。 123456789101112131415161718192021function SuperType()&#123; this.property=true;&#125;SuperType.prototype.getSuperValue=function()&#123; return this.property;&#125;;function SubType()&#123; this.subproperty=false;&#125;//继承了SuperTypeSubType.prototype=new SuperType();//添加新方法SubType.prototype.getSubValue=function()&#123; return this.subproperty;&#125;;//重写父类中的方法SubType.prototype.getSuperValue=function()&#123; return false;&#125;;var ins=new SubType();console.log(ins.getSuperValue());//false; 通过子类实例调用的是重写后的方法，但通过父类实例调用的是重写前的方法。 通过原型链实现继承时，不能使用对象字面量创建原型方法，这样会重写原型链 原型链的问题引用类型的值的原型会被所有实例共享，也就是为什么在构造函数中定义属性，而不在原型中定义属性的原因 1234567891011function SuperType()&#123; this.colors=[\"red\",\"blue\"];&#125;function SubType()&#123;&#125;//继承了SuperTypeSubType.prototype=new SuperType();var ins1=new SubType();ins1.colors.push(\"black\") //\"red,blue,black\"var ins2=new SubType();console.log(ins2.colors); //\"red,blue,black\" SuperType构造函数定义了一个colors引用类型属性，SuperType的每个实例都会包含自己的colors数组，当SubType继承SuperType时，SubType.prototype就成了SuperType的一个实例，它有了自己的colors属性–SubType.prototype.colors属性一样。所有SubType实例共享这一个属性。 第二个问题：创建子类型的实例时，不能向超类型的构造函数中传递参数。实际上，应该说没有办法在不影响所有对象实例的情况下，给超类型的构造函数传递参数。 借用构造函数为解决原型中包含引用类型值的问题，引入了借用构造函数的技术。即在子类型构造函数的内部调用超类型构造函数。通过使用apply()和call()方法可以在新创建的对象上执行构造函数 1234567891011function SuperType()&#123; this.colors=[\"red\",\"blue\"];&#125;function SubType()&#123; //继承了SuperType SuperType.call(this);&#125;var ins1=new SubType();ins1.colors.push(\"black\"); //\"red,blue,black\"var ins2=new SubType(); //\"red,blue\" 传递参数相对原型链，借用构造函数有一个很大优势，即可以在子类型构造函数中向超类型构造函数传递参数 123456789function SuperType(name)&#123; this.name=name;&#125;function SubType()&#123; //继承SuperType，并传递参数 SuperType.call(this,\"nich\"); this.age=29;&#125;var ins=new SubType();//\"nich, 29\" 为了确保超类型中的属性不会重写子类型的属性，可以在调用超类型构造函数后，在添加子类型定义的属性 借用构造函数的问题：方法都在构造函数中调用，没有了函数复用，在超类型原型定义的方法，子类不可见，结果所有类型都只能用构造函数模式 组合继承 最常用的继承模式将原型链和借用构造函数组合到一起。思路是使用原型链实现对原型属性和方法的继承，通过借用构造函数实现对实例属性的继承 1234567891011121314151617181920212223242526function SuperType(name)&#123; this.name=name; this.colors=[\"red\",\"blue\"]&#125;SuperType.prototype.sayName=function()&#123; console.log(this.name);&#125;;function SubType(name,age)&#123; //继承属性 SuperType.call(this,name); this.age=age;&#125;//继承方法SubType.prototype=new SuperType();SubType.prototype.constructor=SubType;SubType.prototype.sayAge=function()&#123; console.log(this.age);&#125;;var ins1=new SubType(\"nich\",30);ins1.colors.push(\"black\"); //\"red,blue,black\"ins1.sayName();//\"nich\"ins1.sayAge();//30var ins2=new SubType(\"greg\",20);//\"red,blue\"ins2.sayName()//\"greg\"ins2.sayAge()//\"20\" 原型式继承这种方式没有使用严格意义上的构造函数。借助原型可以基于已有的对象创建新对象，同时还不必因此创建自定义类型 12345function object(o)&#123; function F()&#123;&#125; F.prototype=o; return new F();&#125; 本质上讲，object()对传入的对象执行了一次浅复制 12345678910111213var person=&#123; name:\"Nich\", friends:[\"shelby\",\"court\"]&#125;;var anotherPerson=object(person);anotherPerson.name=\"greg\";anotherPerson.friends.push(\"rob\");var yetAnotherPerson=object(person);yetAnotherPerson.name=\"linda\";yetAnotherPerson.friends.push(\"barbie\");console.log(person.friends) //\"shelby,court,rob,barbie 必须有一个对象可以作为另一个对象的基础，Person对象可以作为其他对象的基础，调用object后，新对象的原型就为person。person.friends被所有子类型实例共享。相当于创建了person对象的两个副本。 ECMAScript5新增Object.create()规范化了原型式继承，接收两个参数，一个用作新对象原型的对象和（可选的）一个为新对象定义额外属性的对象。只有一个参数时和object()方法的行为相同。第二个参数与Object.defineProperties()方法的第二个参数格式相同：每个属性都是通过自己的描述符定义的，以这种方式定义的任何属性都会覆盖原型对象上的同名属性 12345678910var person=&#123; name:\"nich\", friends:[\"shelby\",\"court\"]&#125;;var anp=Object.create(person,&#123; name:&#123; value:\"greg\" &#125;&#125;);console.log(anp.name);//greg 在没有必要兴师动众创建构造函数，在两个对象需要保持类似的情况下，原型模式可以胜任。但是引用类型值的属性始终会共享相应的值。 寄生式继承寄生式继承的思路与寄生构造函数和工厂模式类似，即创建一个仅用于封装继承过程的函数，该函数在内部以某种方式增强对象，最后像真地是做了所有工作一样返回对象 1234567function createAnother(original)&#123; var clone=object(original); //通过调用函数创建一个新对象 clone.sayHi=function()&#123; //以某种方式来增强对象 console.log(\"hi\"); &#125;; return clone; //返回对象&#125; 123456var person=&#123; name:\"nich\", fri:[\"shelby\",\"court\"]&#125;;var anop=createAnother(person);anotherPerson.sayHi(); //\"hi\" 在主要考虑对象而不是自定义类型和构造函数的情况下，寄生式继承是一种有用的模式。object()函数不是必须的，任何能够返回新对象的函数都适用于此模式。使用寄生继承为对象添加函数，会由于不能做到函数复用而降低效率。 寄生组合式继承 是引用类型最理想的继承范式组合继承最大问题就是无论什么情况，都会调用两次超类型的构造函数，一次在创建子类型原型的时候，另一次是在子类型构造函数内部。 寄生组合式继承，即通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。思路是：不必为了指定子类型的原型而调用超类型的构造函数，我们需要的无非就是超类型原型的一个副本而已。本质就是用寄生式继承来继承超类型的原型，然后在将结果指定给子类型的原型。 123456function inheritPrototype(subType,superType)&#123; var prototype=object(superType.prototype); //创建对象 prototype.constructor=subType; //增强对象 subType.prototype=prototype; //指定对象&#125;//先创建超类型的副本，为副本添加constructor属性，弥补因重写原型失去的默认的constructor属性，将创建的副本赋值给子类型的原型 12345678910111213141516function SuperType(name)&#123; this.name=name; this.colors=[\"red\",\"blue\"];&#125;SuperType.prototype.sayName=function()&#123; console.log(this.name);&#125;;function SubType(name,age)&#123; SuperType.call(this,name); this.age=age;&#125;inheritPrototype(SubType,SuperType);SubType.prototype.sayAge=function()&#123; console.log(this.age);&#125;;//只调用了一次SuperType构造函数，避免了在SubType.prototype上面创建不必要的、多余的属性。","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"},{"name":"js高级程序设计","slug":"js高级程序设计","permalink":"http://yoursite.com/tags/js%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"原型模式","date":"2020-07-26T03:57:01.000Z","path":"2020/07/26/原型模式/","text":"原型模式创建的每个函数都有一个prototype(原型)属性，这个属性是一个指针，指向一个对象。而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。 使用原型对象的好处是可以让所有对象实例共享它所包含的属性和方法。也就是，可以将希望共享的信息放到原型对象中，而不是构造函数中。 12345678910111213function Person()&#123;&#125;Person.prototype.name=\"Nich\";Person.prototype.age=29;Person.prototype.job=\"ali\";Person.prototype.sayName=function()&#123; console.log(this.name);&#125;var person1=new Person();person1.sayName(); //\"Nich\";var person2=new Person();person2.sayName() //\"Nich\";console.log(person1.sayName==person2.sayName) //true 理解原型对象所有的原型对象都有一个constructor(构造函数)属性，这个属性包含一个指向prototype属性所在函数的指针。Person.prototype.constructor指向Person。通过这个构造函数，可以继续为原型对象添加其他属性和方法。 创建自定义对象后，原型对象只会获得constructor属性，其他方法只能通过Object继承得到。调用构造函数创建一个新实例后，该实例内部将包含一个指针(内部属性),指向构造函数的原型对象。这个连接存在于实例与构造函数的原型对象之间，而不是存在于实例与构造函数之间。 在所有实现中都无法访问到[[Prototype]]，但可以通过isPrototypeOf()方法来确定对象之间是否存在这种关系。本质上讲，如果[[Prototype]]指向调用isPrototypeOf()方法的对象(Person.prototype)，那么这个方法返回true 1console.log(Person.prototype.isPrototypeOf(person1)); //true ECMAScript5增加了一个新方法，叫Object.getPrototypeOf(),在所支持的实现中，这个方法返回[[Prototype]]的值。 1console.log(Object.getPrototypeOf(person1)==Person.prototype) //true 代码读取对象的属性时，会执行一次搜索，首先从对象实例本身开始，若找到，则返回属性值，若每找到，则继续搜索指针指向的原型对象，若找到，则返回属性值。 可以通过对象实例访问到原型中的constructor属性。不能通过对象实例重写原型中的值，若对象实例中的属性和原型属性同名，则在对象实例创建该属性，屏蔽原型属性使用delete操作符可以完全删除实例属性，从而可以重新访问到原型中的属性。 hasOwnProperty()方法可以检测一个属性是存在于实例中，还是存在于原型中。这个方法只在给定属性存在于对象实例中时，才会返回true。 123console.log(person1.hasOwnProperty(\"name\")) //false //实例中不存在person1.name=\"Greg\"; //\"Greg\" console.log(person1.hasOwnProperty(\"name\")) //true //来自实例 ECMAScript的Object.getOwnPropertyDescriptor()方法只能用于实例属性，要取得原型属性的描述符，必须之间在原型对象上调用Object.getOwnPropertyDescriptor()方法 原型与in操作符两种方式使用in操作符：单独使用和在for-in循环中使用单独使用时，in操作符会在通过对象能够访问给定属性时返回true，无论属性存在于实例中还是原型中。 123456789console.log(person1.hasOwnProperty(\"name\")); //fasle name存在于原型中console.log(\"name\" in person1) //true 原型中存在nameperson1.name=\"Greg\" //实例中存在nameconsole.log(person1.hasOwnProperty(\"name\")) //trueconsole.log(\"name\" in person1) //truedelete person1.name; //删除实例中nameconsole.log(person1.name) //\"Nich\" //原型 1234//判断属性存在于对象实例中还是原型中function hasPrototypeProperty(object,name)&#123; return !object.hasOwnProperty(name)&amp;&amp;(name in object);&#125; 在使用for-in循环时，返回的是所有能够通过对象访问的、可枚举的(enumerated)属性，其中既包括存在于实例中的属性，也包括原型中的属性。屏蔽了原型中的不可枚举属性(即将[[enumerable]]标记为false的属性)的实例属性也会在for-in循环中返回。因为所有开发人员定义的属性都是可枚举的不可枚举的属性和方法：hasOwnProperty()、propertyIsEnumerable()、toLocaleString()、toString()和valueOf()。ECMAScript5也将constructor和prototype属性的[[Enumerable]]特性设置为false。 可以使用ECMAScript5的Object.keys()方法来获取对象上所有可枚举的实例属性。这个方法接收一个对象作为参数，返回一个包含所有可枚举属性的字符串数组 Object.getOwnPropertyNames()可以返回所有实例属性，无论是否可枚举。以上两个方法可以替代for-in循环 更简单的原型语法使用包含所有属性和方法的对象字面量重写整个原型对象。 123456789function Person()&#123;&#125;Person.prototype=&#123; name:\"Nich\", age:29, job:\"ali\", sayName:function()&#123; console.log(this.name); &#125;&#125;; 问题：constructor属性不在指向Person,而指向Object构造函数，尽管instanceof操作符还能返回正确结果，但通过constructor已经无法确定对象的类型了 12345var fri=new Person();console.log(fri instanceof Object) //trueconsole.log(fri instanceof Person) //trueconsole.log(fri.constructor ==Person) //falseconsole.log(fri.constructor ==Object) //true 可以手动给Person.prototype添加一个construcotr属性 12345Person.prototype=&#123; constructor:Person, ...&#125;//手动重设constructor属性会导致它的[[Enumerable]] 特性被设置为true，但默认是不可枚举的 ECMAScript5可以使用Object.defineProperty() 123456//重设构造函数，只适用于ECMAScript5兼容的浏览器Object.defineProperty(Person.prototype,\"constructor\",&#123; enumerable:false, value:Person&#125;); 原型的动态性由于在原型上的查找值的过程是一次搜索，因此我们对原型对象所做的任何修改都能够立即从实例上反应出来—即使是先创建了实例后修改原型也如此 12345678var f=new Person();Person.prototype.sayHi=function()&#123; alert(\"hi\");&#125;f.sayHi(); //\"hi\"//先创建了一个Person的实例，而后在Person原型中添加方法，即使先创建实例在添加方法前执行，仍可访问方法//因为实例与原型之间的连接只不过是一个指针，而非一个副本，因此就可以在原型中找到新的sayHi属性并返回保存在那里的函数。//若重写了原型对象，就和前面情况不一样了 请注意，实例中的指针仅指向原型，而不指向构造函数。1234567891011function Person()&#123;&#125;var f=new Person();Person.prototype=&#123; constructor:Person, .. sayName:function()&#123; console.log(this.name) &#125;&#125;;f.sayName(); //error//因为f指向的原型中不包含以该名字命名的属性 由图可以看出，重写原型对象切断了现有原型与任何之前已经存在的对象实例之间的联系。它们引用的仍然是最初的原型。 原生对象的原型所有原生的引用类型(Object,Array,String,等等)都在其构造函数的原型上定义了方法。如，在Array.prototype中可以找到sort()方法,而在String.prototype中可以找到substring()方法， 通过原生对象的原型，不仅可以取得所有默认方法的引用，而且也可以定义新方法。可以像修改自定义对象的原型一样修改原生对象的原型，可以随时添加方法。 123456//给String添加了一个名为startsWith()的方法String.prototype.startsWith=function (text)&#123; return this.indexOf(text)==0;&#125;;var msg=\"hello world\";console.log(msg.startsWith(\"hello\"))//true 原型对象的问题原型模式省略了给构造函数传递参数的环节，导致所有实例在默认情况下都会得到相同属性值原型中的所有属性被实例共享，对于基本类型在属性，没什么问题，但对于引用类型值的属性，问题就突出修改一个实例中的某个引用类型值后，另一个实例中的引用类型值也会修改。 组合使用构造函数模式和原型模式构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性。 1234567891011121314151617181920function Person(name,age,job)&#123; this.name=name; this.age=age; this.job=job; this.friends=[\"shelby\",\"court\"];&#125;Person.prototype=&#123; constructor:Person, sayName:function()&#123; console.log(this.name); &#125;&#125;var person1=new Person(\"nich\",29,\"software\");var person2=new Person(\"greg\",27,\"doctor\");person1.friends.push(\"van\");console.log(person1.friends); //\"shelby,court,van\"console.log(person2.friends); //\"shelby,court\"console.log(person1.friends==person2.friends); //falseconsole.log(person1.sayName==person2.sayName); //true 这种构造函数与原型混成的模式，是目前ECMAScript中使用最广泛、认同度最高的一种创建自定义类型的方法。 动态原型模式动态原型模式将所有信息封装在构造函数中，通过构造函数初始化原型(仅在必要情况下),保持了构造函数和原型的优点 123456789101112131415function Person(name,age,job)&#123; //属性 this.name=name; this.age=age; this.job=job; //方法 //通过判断方法是否存在，来初始化原型，还可以使用instanceof操作符判断类型 if(typeof this.sayName!=\"function\")&#123; Person.prototype.sayName=function()&#123; console.log(this.name); &#125;; &#125;&#125;var f=new Person(\"nich\",30,\"soft\");f.sayName(); 使用动态原型模式时，不能使用对象字面量重写原型。若重写，就会切断现有实例与新原型之间的联系。 寄生构造函数模式寄生构造函数模式思想是创建一个函数，该函数作用仅仅是封装创建对象的代码并返回对象 12345678910function Person(name,age,job)&#123; var o=new Object(); o.name=name; o.sayName=function()&#123; console.log(this.name); &#125; return o;&#125;var f=new Person(\"nich\",30,\"ali\");f.sayName(); //\"nich\" 除了使用new操作符创建对象并把使用的包装函数叫做构造函数外，其他和工厂模式一样构造函数在不返回值的情况下，会默认返回新对象实例。在构造函数末尾加return，可以重写调用构造函数时返回的值 可以在特殊情况下为对象创建构造函数。创建一个具有额外方法的数组。由于不能之间修改Array构造函数，可以使用该模式 1234567891011121314function SpecialArray()&#123; //创建数组 var values=new Array(); //添加值 values.push.apply(values,arguments); //把values.push方法作用域改为values实例上，传入arguments参数 //添加方法 values.toPipedString=function()&#123; return this.join(\"|\"); &#125; return values;&#125;var colors=new SpecialArray(\"red\",\"blue\");console.log(colors.toPipedString()) //\"red|blue\" 关于寄生构造函数模式，首先，返回的对象与构造函数或者构造函数的原型属性之间没有关系。也就是说，构造函数返回的对象与在构造函数外部创建的对象没有什么不同。所以不能依赖instanceof操作符来确定对象类型。所以，可以使用其他模式的情况下，不要使用这种模式。 稳妥构造函数模式稳妥对象就是没有公共属性，而且其方法也不引用this对象。稳妥对象最适合在一些安全环境中（禁止使用this和new），或防止数据被其他应用程序改动时使用。稳妥模式与寄生模式类似。有两点不同，一是新创建对象的实例方法不引用this，二是不使用new操作符调用构造函数。 1234567891011function Person(name,age,job)&#123; //创建要返回的对象 var o=new Object(); //可以在这里定义私有变量和函数 //添加方法 o.sayName=function()&#123; console.log(name); &#125; return o;&#125; 这种模式只能通过sayName方法访问name值，即使有其他代码给这个对象添加方法或数据成员，也不能通过其他方法访问name值与寄生模式类似，使用稳妥构造函数模式创建的对象与构造函数之间没什么关系，instanceof对这种对象没意义","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"},{"name":"js高级程序设计","slug":"js高级程序设计","permalink":"http://yoursite.com/tags/js%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"每日算法01","date":"2020-07-25T04:44:36.000Z","path":"2020/07/25/每日算法01/","text":"剪绳子给你一根长度为n的绳子，请把绳子剪成整数长的m段(m、n都是整数，n&gt;1并且m&gt;1,m&lt;=n),每段绳子的长度记为k[1],…k[m]。请问k[1]…k[m]可能的最大乘积是多少？ 例如，当绳子的长度为8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18. 贪心法12345678910111213141516171819202122232425262728293031323334353637public int cutRope(int target)&#123; //4 2*2 //5 2*3 //6 3*3 //7 2*2*3 4*3 //8 2*3*3 //9 3*3*3 //10 2*2*3*3 4*3*3 //11 2*3*3*3 //由以上举的例子可以看出，最后情况只可能为2或3 //由3(n-3)&gt;=2(n-2)，可知当n=5时，等式相等，当n&gt;5时，应让3尽量的多。 if(target&lt;2)&#123; return 0; &#125; if(target==2)&#123; //由题知m&gt;1,所以2为1*1=1 return 1; &#125; if(target==3)&#123; //m&gt;1,所以3为2*1=1 return 2; &#125; if(target%3==0)&#123; //当绳子长刚好为3的倍数，则结果为3的（target/3）次幂 return (int)Math.pow(3,target/3); &#125;else if(target%3==1)&#123; //当绳子长对3取余刚好等于1时，可以多留出一个3，结果就为3的（target/3-1）次幂乘以4 return 4*(int)Math.pow(3,target/3-1); &#125;else&#123; //当绳子长对3取余刚好等于2时，留出2，结果就为3的（target/3）次幂乘以2 return 2*(int)Math.pow(3,target/3); &#125;&#125;public static void main(String[] args) &#123; System.out.println(cutRope(8));//18 System.out.println(cutRope(9));//27&#125; 动态规划法123456789101112131415161718192021222324252627282930313233//一个比较简单的动态规划//求问题最优解，该问题可以分成若干个子问题，子问题之间还有重叠的更小的子问题，考虑使用动态规划。//以自上而下分析，在长度为n的绳子剪下乘积为f(n),剪下i长度后，还剩n-i，即得公式//f(n)=max(f(i)*f(n-i))//为了避免重复计算子问题，以从下往上的顺序计算小问题的解并保存下来，在以此为基础求解更大问题。//每public int cutRope(int target)&#123; if(target&lt;2)&#123; return 0; &#125; if(target==2)&#123; return 1; &#125; if(target==3)&#123; return 2; &#125; int []dp=new int[target+1]; dp[1]=1; dp[2]=2; dp[3]=3;//1 2 3 都是不剪绳子，得到的乘积最大 int res=0;//记录每次剪完的最大值 for (int i=4;i&lt;=target;i++)&#123; for (int j=1;j&lt;=i/2;j++)&#123;//要计算j*i-j的最大值，所以只用计算j&lt;=i的值 res=Math.max(res,dp[j]*dp[i-j]);//得到长度为i时，所有剪法的最大值 &#125; dp[i]=res;//得到当前剪法的最大值，保存到dp数组中 &#125; return dp[target];//返回最大值&#125;public static void main(String[] args) &#123; System.out.println(cutRope(8));//18 System.out.println(cutRope(9));//27&#125; sdfsfs","tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"贪心法","slug":"贪心法","permalink":"http://yoursite.com/tags/%E8%B4%AA%E5%BF%83%E6%B3%95/"},{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"js复习","date":"2020-07-25T00:44:37.000Z","path":"2020/07/25/js复习/","text":"RegExp类型ECMAScript通过RegExp类型来支持正则表达式 1var express=/ pattern / flags; 正则表达式的匹配模式支持下列3个标志123g:表示全局（global）模式，即模式被应用于所有字符串，而不是在遇到第一个匹配项立即停止i：表示不区分大小写（case-insensitive)模式m：表示多行（multiline）模式，即在一行到达文本末尾时还会继续查找下一行 模式中使用的所有元字符都必须转义，元字符包括1( [ &#123; \\ ^ $ | ? * + .&#125; ] ) 创建正则表达式两种方式字面量模式： 1var pattern1=/[bc]at/i; RegExp构造函数模式：接收两个参数，一个是匹配的字符串模式，一个是可选的标志字符串 1var pattern2=new RegExp(\"[bc]at\",\"i\"); 在ECMAScript3中，字面量模式始终会共享一个RegExp实例，而使用构造函数创建的每一个新RegExp实例都是一个新实例，在ECMAScript5中明确字面量修改为每次都创建RegExp实例 12345678910var re=null, i;for(i=0;i&lt;10;i++)&#123; re=/cat/g; console.log(re.test(\"catastrophe\"));&#125;for(i=0;i&lt;10;i++)&#123; re=new RegExp(\"cat\",\"g\"); console.log(re.test(\"catastrophe\"));&#125; RegExp实例属性12345global:布尔值，表示是否设置了g标志ignoreCase:布尔值，表示是否设置了i标志lastIndex:整数，表示开始搜索下一个匹配项的字符位置，从0算起multiline：布尔值，表示是否设置了m标志source：正则表达式的字符串表示，按照字面量形式而非传入构造函数中的字符串模式返回 RegExp实例方法捕获组：把正则表达式中子表达式匹配的结果，分组按顺序保存，之后可以通过序号或名称来使用这些内容。目前，js只能通过序号访问。 RegExp对象的主要方法为exec()，该方法主要为捕获组，接收一个要应用模式的字符串，返回包含第一个匹配项信息的数组，返回的数组为Array的实例，包含额外的两个属性：index和input，index表示匹配项在字符串中的位置，input表示应用正则表达式的字符串。 123456789var text=\"mom and dad and baby\";var pattern= /mom( and dad( and baby)?)?/gi;var matches=pattern.exec(text);console.log(matches.index) //0console.log(matches.input) //\"mom and dad and baby\"console.log(matches[0]) //\"mom and dad and baby\"console.log(matches[1]) //\"and dad and baby\"console.log(matches[2]) //\" and baby\" 对于exec()方法，在同一个字符串上调用多次exex()方法，若不设置g标志，每次都会返回第一个匹配项的信息，lastIndex始终保持不变，若设置了全局标志，每次都会在字符串中继续查找新的匹配项，lastIndex会变化。 RegExp中的另一个方法test()接收一个字符串参数。在模式与参数匹配情况下返回true，否则返回false。 123456var text=\"000-00-0000\";var pattern=/\\d&#123;3&#125;-\\d&#123;2&#125;-\\d&#123;4&#125;/;if(pattern.test(text))&#123; console.log(\"matched\");//matched&#125; RegExp实例继承的toLocaleString()和toString()方法都会返回正则表达式的字面量，与创建方式无关。正则表达式的valueOf()方法返回正则表达式本身。 RegExp构造函数属性这些属性适用于作用域中的所有正则表达式，并且给予所执行的最佳一次正则表达式操作而变化。 123456input 最近一次要匹配的字符串lastMatch 最近一次的匹配项lastParen 最近一次匹配的捕获组leftContext input字符串中lastMatch之前的文本multiline 布尔值，表示是否表达式都使用多行表示rightContext input字符串中lastMathch之后的文本 123456789101112131415var text=\"this has been a short summary\";var pattern=/(.)hort/g;/**opera不支持input lastmatch lastparen multiline*ie 不支持multiline*/if(pattern.test(text))&#123; console.log(RegExp.input); //this has been a short summary console.log(RegExp.leftContext); //this has been a console.log(RegExp.rightContext); //summary console.log(RegExp.lastMatch) //short console.log(RegExp.lastParen) //s console.log(RegExp.multiline) //false chrome中为undefined&#125; 除以上几个属性外，还要9个用于存储捕获组的构造函数属性，为RegExp.$1,RegExp.$2…RegExp.$9。调用exec()和test()时，这些属性会被自动填充。 模式的局限性ECMAScript中的正则表达式缺少了某些高级特性 1234567891.匹配字符串开始和结尾的\\A和\\Z锚2.向后查找3.并集和交集类4.原子组5.Unicode支持(单个字符除外，如\\uFFFF)6.命名的捕获组7.s(single,单行) 和x(free-spacing,无间隔) 匹配模式8.条件匹配9.正则表达式注释","tags":[{"name":"正则表达式","slug":"正则表达式","permalink":"http://yoursite.com/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"},{"name":"js高级程序设计","slug":"js高级程序设计","permalink":"http://yoursite.com/tags/js%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"第一篇博客","date":"2020-07-24T14:00:03.000Z","path":"2020/07/24/第一篇博客/","text":"大家好，我是一名计算机专业的学生。啥都不会，但啥都想学。这是我人生第一次写文章，我写文章的主要目的就是想把学习中遇到的知识点、问题及解决方案记录下来，方便以后随时可以拿来复习。写文章对自己来说也是一种记录成长的方式，见证自己的成长，不忘初心。希望大家多多提出一些意见，交流一下学习经验，希望结交更多的朋友，互相学习。自己的表达能力很欠缺，希望通过写文章可以提高自己的文章写作能力。后面我会分享的内容有前端、后端、数据库、算法与数据结构、面试题、设计模式、计算机基础、机器学习等一些学习资源。努力奋斗","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"}]}]