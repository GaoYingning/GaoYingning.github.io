[{"title":"每日算法01","date":"2020-07-25T04:44:36.000Z","path":"2020/07/25/每日算法01/","text":"剪绳子给你一根长度为n的绳子，请把绳子剪成整数长的m段(m、n都是整数，n&gt;1并且m&gt;1,m&lt;=n),每段绳子的长度记为k[1],…k[m]。请问k[1]…k[m]可能的最大乘积是多少？ 例如，当绳子的长度为8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18. 贪心法12345678910111213141516171819202122232425262728293031323334353637public int cutRope(int target)&#123; //4 2*2 //5 2*3 //6 3*3 //7 2*2*3 4*3 //8 2*3*3 //9 3*3*3 //10 2*2*3*3 4*3*3 //11 2*3*3*3 //由以上举的例子可以看出，最后情况只可能为2或3 //由3(n-3)&gt;=2(n-2)，可知当n=5时，等式相等，当n&gt;5时，应让3尽量的多。 if(target&lt;2)&#123; return 0; &#125; if(target==2)&#123; //由题知m&gt;1,所以2为1*1=1 return 1; &#125; if(target==3)&#123; //m&gt;1,所以3为2*1=1 return 2; &#125; if(target%3==0)&#123; //当绳子长刚好为3的倍数，则结果为3的（target/3）次幂 return (int)Math.pow(3,target/3); &#125;else if(target%3==1)&#123; //当绳子长对3取余刚好等于1时，可以多留出一个3，结果就为3的（target/3-1）次幂乘以4 return 4*(int)Math.pow(3,target/3-1); &#125;else&#123; //当绳子长对3取余刚好等于2时，留出2，结果就为3的（target/3）次幂乘以2 return 2*(int)Math.pow(3,target/3); &#125;&#125;public static void main(String[] args) &#123; System.out.println(cutRope(8));//18 System.out.println(cutRope(9));//27&#125; 动态规划法123456789101112131415161718192021222324252627282930313233//一个比较简单的动态规划//求问题最优解，该问题可以分成若干个子问题，子问题之间还有重叠的更小的子问题，考虑使用动态规划。//以自上而下分析，在长度为n的绳子剪下乘积为f(n),剪下i长度后，还剩n-i，即得公式//f(n)=max(f(i)*f(n-i))//为了避免重复计算子问题，以从下往上的顺序计算小问题的解并保存下来，在以此为基础求解更大问题。//每public int cutRope(int target)&#123; if(target&lt;2)&#123; return 0; &#125; if(target==2)&#123; return 1; &#125; if(target==3)&#123; return 2; &#125; int []dp=new int[target+1]; dp[1]=1; dp[2]=2; dp[3]=3;//1 2 3 都是不剪绳子，得到的乘积最大 int res=0;//记录每次剪完的最大值 for (int i=4;i&lt;=target;i++)&#123; for (int j=1;j&lt;=i/2;j++)&#123;//要计算j*i-j的最大值，所以只用计算j&lt;=i的值 res=Math.max(res,dp[j]*dp[i-j]);//得到长度为i时，所有剪法的最大值 &#125; dp[i]=res;//得到当前剪法的最大值，保存到dp数组中 &#125; return dp[target];//返回最大值&#125;public static void main(String[] args) &#123; System.out.println(cutRope(8));//18 System.out.println(cutRope(9));//27&#125;","tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"贪心法","slug":"贪心法","permalink":"http://yoursite.com/tags/%E8%B4%AA%E5%BF%83%E6%B3%95/"},{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"js复习","date":"2020-07-25T00:44:37.000Z","path":"2020/07/25/js复习/","text":"RegExp类型ECMAScript通过RegExp类型来支持正则表达式 1var express=/ pattern / flags; 正则表达式的匹配模式支持下列3个标志123g:表示全局（global）模式，即模式被应用于所有字符串，而不是在遇到第一个匹配项立即停止i：表示不区分大小写（case-insensitive)模式m：表示多行（multiline）模式，即在一行到达文本末尾时还会继续查找下一行 模式中使用的所有元字符都必须转义，元字符包括1( [ &#123; \\ ^ $ | ? * + .&#125; ] ) 创建正则表达式两种方式字面量模式： 1var pattern1=/[bc]at/i; RegExp构造函数模式：接收两个参数，一个是匹配的字符串模式，一个是可选的标志字符串 1var pattern2=new RegExp(\"[bc]at\",\"i\"); 在ECMAScript3中，字面量模式始终会共享一个RegExp实例，而使用构造函数创建的每一个新RegExp实例都是一个新实例，在ECMAScript5中明确字面量修改为每次都创建RegExp实例 12345678910var re=null, i;for(i=0;i&lt;10;i++)&#123; re=/cat/g; console.log(re.test(\"catastrophe\"));&#125;for(i=0;i&lt;10;i++)&#123; re=new RegExp(\"cat\",\"g\"); console.log(re.test(\"catastrophe\"));&#125; RegExp实例属性12345global:布尔值，表示是否设置了g标志ignoreCase:布尔值，表示是否设置了i标志lastIndex:整数，表示开始搜索下一个匹配项的字符位置，从0算起multiline：布尔值，表示是否设置了m标志source：正则表达式的字符串表示，按照字面量形式而非传入构造函数中的字符串模式返回 RegExp实例方法捕获组：把正则表达式中子表达式匹配的结果，分组按顺序保存，之后可以通过序号或名称来使用这些内容。目前，js只能通过序号访问。 RegExp对象的主要方法为exec()，该方法主要为捕获组，接收一个要应用模式的字符串，返回包含第一个匹配项信息的数组，返回的数组为Array的实例，包含额外的两个属性：index和input，index表示匹配项在字符串中的位置，input表示应用正则表达式的字符串。 123456789var text=\"mom and dad and baby\";var pattern= /mom( and dad( and baby)?)?/gi;var matches=pattern.exec(text);console.log(matches.index) //0console.log(matches.input) //\"mom and dad and baby\"console.log(matches[0]) //\"mom and dad and baby\"console.log(matches[1]) //\"and dad and baby\"console.log(matches[2]) //\" and baby\" 对于exec()方法，在同一个字符串上调用多次exex()方法，若不设置g标志，每次都会返回第一个匹配项的信息，lastIndex始终保持不变，若设置了全局标志，每次都会在字符串中继续查找新的匹配项，lastIndex会变化。 RegExp中的另一个方法test()接收一个字符串参数。在模式与参数匹配情况下返回true，否则返回false。 123456var text=\"000-00-0000\";var pattern=/\\d&#123;3&#125;-\\d&#123;2&#125;-\\d&#123;4&#125;/;if(pattern.test(text))&#123; console.log(\"matched\");//matched&#125; RegExp实例继承的toLocaleString()和toString()方法都会返回正则表达式的字面量，与创建方式无关。正则表达式的valueOf()方法返回正则表达式本身。 RegExp构造函数属性这些属性适用于作用域中的所有正则表达式，并且给予所执行的最佳一次正则表达式操作而变化。 123456input 最近一次要匹配的字符串lastMatch 最近一次的匹配项lastParen 最近一次匹配的捕获组leftContext input字符串中lastMatch之前的文本multiline 布尔值，表示是否表达式都使用多行表示rightContext input字符串中lastMathch之后的文本 123456789101112131415var text=\"this has been a short summary\";var pattern=/(.)hort/g;/**opera不支持input lastmatch lastparen multiline*ie 不支持multiline*/if(pattern.test(text))&#123; console.log(RegExp.input); //this has been a short summary console.log(RegExp.leftContext); //this has been a console.log(RegExp.rightContext); //summary console.log(RegExp.lastMatch) //short console.log(RegExp.lastParen) //s console.log(RegExp.multiline) //false chrome中为undefined&#125; 除以上几个属性外，还要9个用于存储捕获组的构造函数属性，为RegExp.$1,RegExp.$2…RegExp.$9。调用exec()和test()时，这些属性会被自动填充。 模式的局限性ECMAScript中的正则表达式缺少了某些高级特性 1234567891.匹配字符串开始和结尾的\\A和\\Z锚2.向后查找3.并集和交集类4.原子组5.Unicode支持(单个字符除外，如\\uFFFF)6.命名的捕获组7.s(single,单行) 和x(free-spacing,无间隔) 匹配模式8.条件匹配9.正则表达式注释","tags":[{"name":"正则表达式","slug":"正则表达式","permalink":"http://yoursite.com/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"js高级教程学习笔记","slug":"js高级教程学习笔记","permalink":"http://yoursite.com/tags/js%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"第一篇博客","date":"2020-07-24T14:00:03.000Z","path":"2020/07/24/第一篇博客/","text":"大家好，我是一名计算机专业的学生。啥都不会，但啥都想学。这是我人生第一次写文章，我写文章的主要目的就是想把学习中遇到的知识点、问题及解决方案记录下来，方便以后随时可以拿来复习。写文章对自己来说也是一种记录成长的方式，见证自己的成长，不忘初心。希望大家多多提出一些意见，交流一下学习经验，希望结交更多的朋友，互相学习。自己的表达能力很欠缺，希望通过写文章可以提高自己的文章写作能力。后面我会分享的内容有前端、后端、数据库、算法与数据结构、面试题、设计模式、计算机基础、机器学习等一些学习资源。努力奋斗","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"}]}]