[{"title":"Fucntion类型","date":"2020-07-27T06:43:48.000Z","path":"2020/07/27/Fucntion类型/","text":"函数声明与函数表达式解析器在向执行环境中加载数据时，对函数声明和函数表达式并非一视同仁。解析器会率先读取函数声明，并使其在执行任何代码之前可用（可用访问）至于函数表达式，则必须等到解析器执行到它所在的代码行，才会真正被解释执行。 1234alert(sum(10,10))function sum(num1,num2)&#123; return num1+num2;&#125; 在代码开始执行之前，解析器就已经通过一个函数声明提升（function declaration hoisting）的过程，读取并将函数声明添加到执行环境中。js引擎在第一遍会声明函数并将它们放到源代码树的顶部。所以，即使声明函数的代码在调用它的代码后面，js引擎也会把函数声明提升到顶部。但函数表达式不会进行函数声明提升 函数内部属性函数内部包含两个对象：arguments和thisarguments主要用途是保存函数参数，这个对象还有一个callee属性，该属性是一个指针，指向拥有这个arguments对象的函数 123456789101112131415function factorial(num)&#123; if(num&lt;1)&#123; return 1; &#125;else&#123; return num*factorial(num-1); &#125;&#125;//这个函数的执行和函数名紧紧耦合在一起了，为了消除这种耦合现象，可用使用arguments.calleefunction factorial(num)&#123; if(num&lt;1)&#123; return 1; &#125;else&#123; return num*arguments.callee(num-1); &#125;&#125; this引用的是函数据以执行的环境对象函数的名字仅仅是一个包含指针的变量而已。 ECMAScript5规范化了另一个函数对象的属性：caller，属性中保存着调用当前函数的函数的引用，若全局作用域调用当前函数，它为null 当函数在严格模式下，访问arguments.callee会导致错误，访问arguments.caller也会出错，在非严格模式下 arguments.caller始终是undefined。定义这个属性是为了区分arguments.caller和caller属性。严格模式下，不能为函数的caller属性赋值，否则会导致错误。 每个函数都包含两个非继承而来的方法：apply()和call()都是在特定的作用域中调用函数，实际上等于设置函数体内this对象的值。apply方法接收两个参数，一个是在其中运行的作用域，另一个是参数数组。其中，第二个参数可用是Array实例，也可用是arguments对象。 12345678function sum(num1,num2)&#123; return num1+num2;&#125;function callSum1(num1,num2)&#123; return sum.apply(this,arguments) &#125;console.log(callSum1(10,10))//20//callSum1在执行sum时传入this作为this值（因为是在全局作用域中调用的，所以传入的就是window对象）和argumets对象 在严格模式下，未指定环境对象而调用函数，则this值不会转型为window。除非明确把函数添加到某个对象或者调用apply()或call()，否则this值将是undefined call()方法和apply()方法作用相同，区别仅在于接收参数的方式不同。call()第一个参数是this，其他参数直接传递给函数，传递给函数的参数必须逐个列举出来。 1234567function sum(num1,num2)&#123; return num1+num2;&#125;function callSum(num1,num2)&#123; return sum.call(this,num1,num2);&#125;console.log(callSum(10,10)); //20 apply()和call()真正的作用在于扩充函数执行的作用域123456789window.color=\"red\";var o=&#123;color:\"blue\"&#125;;function sayColor()&#123; console.log(this.color);&#125;sayColor();//redsayColor.call(this)//redsayColor.call(window)//redsayColor.call(o);//blue 使用call()和apply()扩充作用域最大好处是对象不需要与方法有任何耦合关系。 bind()函数，这个方法会创建一个函数的实例，其this值会被绑定到传给bind()函数的值1234567window.color=\"red\";var o=&#123;color:\"blue\"&#125;;function sayColor()&#123; console.log(this.color);&#125;var objectSayColor=sayColor.bind(o);objectSayColor();//blue","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"},{"name":"js高级程序设计","slug":"js高级程序设计","permalink":"http://yoursite.com/tags/js%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"继承","date":"2020-07-27T00:35:46.000Z","path":"2020/07/27/继承/","text":"ECMAScript实现继承主要是依赖原型链。 原型链基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。 假如让原型对象等于另一个类型的实例，此时原型对象就会包含一个指向另一个原型的指针，另一个原型中也会包含一个指向另一个构造函数的指针，层层递进。这就是原型链的基本概念 基本模式 1234567891011121314151617function SuperType()&#123; this.property=true;&#125;SuperType.prototype.getSuperValue=function()&#123; return this.property;&#125;;function SubType()&#123; this.subproperty=false;&#125;//继承了SuperTypeSubType.prototype=new SuperType();SubType.prototype.getSubValue=function()&#123; return this.subproperty;&#125;;var instance=new SubType();console.log(instance.getSuperValue()); //true 在上面代码中，我们将SubType的原型替换为了新原型即SuperType的实例。新原型不仅具有作为一个SuperType的实例所拥有的全部属性和方法，其内部还有一个指针，指向了SuperType的原型最终结果为：instance指向SubType的原型，SubType的原型又指向SuperType的原型。GetSuperValue方法仍然在SuperType.prototype中，但property则位于SubType.prototype中，因为property是一个实例属性，而GetSuperValue是一个原型方法SubType.prototype现在是SuperType的实例，那么property就位于该实例中。instance.constructor现在指向SuperType，因为原来的SubType.prototype中的constructor被重写了，实际上不是重写，而是指向了SuperType的原型，而这个原型对象constructor属性指向SuperType 通过实现原型链，本质上扩展了原型搜索机制 默认的原型所有的原型默认都继承了Object，而这个继承也是通过原型链实现的。 SubType继承了SuperType，而SuperType继承了Object。 确定原型和实例的关系instanceof操作符：只要用这个操作符来测试实例与原型链中出现过的构造函数，结果就为true 1console.log(instance instanceof SuperType) //true isPrototypeOf()方法：同样只要原型链出现过的原型，都可以说是该原型链派生的实例的原型，该方法会返回true。 1console.log(Object.prototype.isPrototypeOf(instance)); //true 谨慎定义方法子类型有时候需要重写父类中的方法，或添加某些方法。但给原型添加方法的代码一定要放在替换原型的语句之后。 123456789101112131415161718192021function SuperType()&#123; this.property=true;&#125;SuperType.prototype.getSuperValue=function()&#123; return this.property;&#125;;function SubType()&#123; this.subproperty=false;&#125;//继承了SuperTypeSubType.prototype=new SuperType();//添加新方法SubType.prototype.getSubValue=function()&#123; return this.subproperty;&#125;;//重写父类中的方法SubType.prototype.getSuperValue=function()&#123; return false;&#125;;var ins=new SubType();console.log(ins.getSuperValue());//false; 通过子类实例调用的是重写后的方法，但通过父类实例调用的是重写前的方法。 通过原型链实现继承时，不能使用对象字面量创建原型方法，这样会重写原型链 原型链的问题引用类型的值的原型会被所有实例共享，也就是为什么在构造函数中定义属性，而不在原型中定义属性的原因 1234567891011function SuperType()&#123; this.colors=[\"red\",\"blue\"];&#125;function SubType()&#123;&#125;//继承了SuperTypeSubType.prototype=new SuperType();var ins1=new SubType();ins1.colors.push(\"black\") //\"red,blue,black\"var ins2=new SubType();console.log(ins2.colors); //\"red,blue,black\" SuperType构造函数定义了一个colors引用类型属性，SuperType的每个实例都会包含自己的colors数组，当SubType继承SuperType时，SubType.prototype就成了SuperType的一个实例，它有了自己的colors属性–SubType.prototype.colors属性一样。所有SubType实例共享这一个属性。 第二个问题：创建子类型的实例时，不能向超类型的构造函数中传递参数。实际上，应该说没有办法在不影响所有对象实例的情况下，给超类型的构造函数传递参数。 借用构造函数为解决原型中包含引用类型值的问题，引入了借用构造函数的技术。即在子类型构造函数的内部调用超类型构造函数。通过使用apply()和call()方法可以在新创建的对象上执行构造函数 1234567891011function SuperType()&#123; this.colors=[\"red\",\"blue\"];&#125;function SubType()&#123; //继承了SuperType SuperType.call(this);&#125;var ins1=new SubType();ins1.colors.push(\"black\"); //\"red,blue,black\"var ins2=new SubType(); //\"red,blue\" 传递参数相对原型链，借用构造函数有一个很大优势，即可以在子类型构造函数中向超类型构造函数传递参数 123456789function SuperType(name)&#123; this.name=name;&#125;function SubType()&#123; //继承SuperType，并传递参数 SuperType.call(this,\"nich\"); this.age=29;&#125;var ins=new SubType();//\"nich, 29\" 为了确保超类型中的属性不会重写子类型的属性，可以在调用超类型构造函数后，在添加子类型定义的属性 借用构造函数的问题：方法都在构造函数中调用，没有了函数复用，在超类型原型定义的方法，子类不可见，结果所有类型都只能用构造函数模式 组合继承 最常用的继承模式将原型链和借用构造函数组合到一起。思路是使用原型链实现对原型属性和方法的继承，通过借用构造函数实现对实例属性的继承 1234567891011121314151617181920212223242526function SuperType(name)&#123; this.name=name; this.colors=[\"red\",\"blue\"]&#125;SuperType.prototype.sayName=function()&#123; console.log(this.name);&#125;;function SubType(name,age)&#123; //继承属性 SuperType.call(this,name); this.age=age;&#125;//继承方法SubType.prototype=new SuperType();SubType.prototype.constructor=SubType;SubType.prototype.sayAge=function()&#123; console.log(this.age);&#125;;var ins1=new SubType(\"nich\",30);ins1.colors.push(\"black\"); //\"red,blue,black\"ins1.sayName();//\"nich\"ins1.sayAge();//30var ins2=new SubType(\"greg\",20);//\"red,blue\"ins2.sayName()//\"greg\"ins2.sayAge()//\"20\" 原型式继承这种方式没有使用严格意义上的构造函数。借助原型可以基于已有的对象创建新对象，同时还不必因此创建自定义类型 12345function object(o)&#123; function F()&#123;&#125; F.prototype=o; return new F();&#125; 本质上讲，object()对传入的对象执行了一次浅复制 12345678910111213var person=&#123; name:\"Nich\", friends:[\"shelby\",\"court\"]&#125;;var anotherPerson=object(person);anotherPerson.name=\"greg\";anotherPerson.friends.push(\"rob\");var yetAnotherPerson=object(person);yetAnotherPerson.name=\"linda\";yetAnotherPerson.friends.push(\"barbie\");console.log(person.friends) //\"shelby,court,rob,barbie 必须有一个对象可以作为另一个对象的基础，Person对象可以作为其他对象的基础，调用object后，新对象的原型就为person。person.friends被所有子类型实例共享。相当于创建了person对象的两个副本。 ECMAScript5新增Object.create()规范化了原型式继承，接收两个参数，一个用作新对象原型的对象和（可选的）一个为新对象定义额外属性的对象。只有一个参数时和object()方法的行为相同。第二个参数与Object.defineProperties()方法的第二个参数格式相同：每个属性都是通过自己的描述符定义的，以这种方式定义的任何属性都会覆盖原型对象上的同名属性 12345678910var person=&#123; name:\"nich\", friends:[\"shelby\",\"court\"]&#125;;var anp=Object.create(person,&#123; name:&#123; value:\"greg\" &#125;&#125;);console.log(anp.name);//greg 在没有必要兴师动众创建构造函数，在两个对象需要保持类似的情况下，原型模式可以胜任。但是引用类型值的属性始终会共享相应的值。 寄生式继承寄生式继承的思路与寄生构造函数和工厂模式类似，即创建一个仅用于封装继承过程的函数，该函数在内部以某种方式增强对象，最后像真地是做了所有工作一样返回对象 1234567function createAnother(original)&#123; var clone=object(original); //通过调用函数创建一个新对象 clone.sayHi=function()&#123; //以某种方式来增强对象 console.log(\"hi\"); &#125;; return clone; //返回对象&#125; 123456var person=&#123; name:\"nich\", fri:[\"shelby\",\"court\"]&#125;;var anop=createAnother(person);anotherPerson.sayHi(); //\"hi\" 在主要考虑对象而不是自定义类型和构造函数的情况下，寄生式继承是一种有用的模式。object()函数不是必须的，任何能够返回新对象的函数都适用于此模式。使用寄生继承为对象添加函数，会由于不能做到函数复用而降低效率。 寄生组合式继承 是引用类型最理想的继承范式组合继承最大问题就是无论什么情况，都会调用两次超类型的构造函数，一次在创建子类型原型的时候，另一次是在子类型构造函数内部。 寄生组合式继承，即通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。思路是：不必为了指定子类型的原型而调用超类型的构造函数，我们需要的无非就是超类型原型的一个副本而已。本质就是用寄生式继承来继承超类型的原型，然后在将结果指定给子类型的原型。 123456function inheritPrototype(subType,superType)&#123; var prototype=object(superType.prototype); //创建对象 prototype.constructor=subType; //增强对象 subType.prototype=prototype; //指定对象&#125;//先创建超类型的副本，为副本添加constructor属性，弥补因重写原型失去的默认的constructor属性，将创建的副本赋值给子类型的原型 12345678910111213141516function SuperType(name)&#123; this.name=name; this.colors=[\"red\",\"blue\"];&#125;SuperType.prototype.sayName=function()&#123; console.log(this.name);&#125;;function SubType(name,age)&#123; SuperType.call(this,name); this.age=age;&#125;inheritPrototype(SubType,SuperType);SubType.prototype.sayAge=function()&#123; console.log(this.age);&#125;;//只调用了一次SuperType构造函数，避免了在SubType.prototype上面创建不必要的、多余的属性。","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"},{"name":"js高级程序设计","slug":"js高级程序设计","permalink":"http://yoursite.com/tags/js%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"原型模式","date":"2020-07-26T03:57:01.000Z","path":"2020/07/26/原型模式/","text":"原型模式创建的每个函数都有一个prototype(原型)属性，这个属性是一个指针，指向一个对象。而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。 使用原型对象的好处是可以让所有对象实例共享它所包含的属性和方法。也就是，可以将希望共享的信息放到原型对象中，而不是构造函数中。 12345678910111213function Person()&#123;&#125;Person.prototype.name=\"Nich\";Person.prototype.age=29;Person.prototype.job=\"ali\";Person.prototype.sayName=function()&#123; console.log(this.name);&#125;var person1=new Person();person1.sayName(); //\"Nich\";var person2=new Person();person2.sayName() //\"Nich\";console.log(person1.sayName==person2.sayName) //true 理解原型对象所有的原型对象都有一个constructor(构造函数)属性，这个属性包含一个指向prototype属性所在函数的指针。Person.prototype.constructor指向Person。通过这个构造函数，可以继续为原型对象添加其他属性和方法。 创建自定义对象后，原型对象只会获得constructor属性，其他方法只能通过Object继承得到。调用构造函数创建一个新实例后，该实例内部将包含一个指针(内部属性),指向构造函数的原型对象。这个连接存在于实例与构造函数的原型对象之间，而不是存在于实例与构造函数之间。 在所有实现中都无法访问到[[Prototype]]，但可以通过isPrototypeOf()方法来确定对象之间是否存在这种关系。本质上讲，如果[[Prototype]]指向调用isPrototypeOf()方法的对象(Person.prototype)，那么这个方法返回true 1console.log(Person.prototype.isPrototypeOf(person1)); //true ECMAScript5增加了一个新方法，叫Object.getPrototypeOf(),在所支持的实现中，这个方法返回[[Prototype]]的值。 1console.log(Object.getPrototypeOf(person1)==Person.prototype) //true 代码读取对象的属性时，会执行一次搜索，首先从对象实例本身开始，若找到，则返回属性值，若每找到，则继续搜索指针指向的原型对象，若找到，则返回属性值。 可以通过对象实例访问到原型中的constructor属性。不能通过对象实例重写原型中的值，若对象实例中的属性和原型属性同名，则在对象实例创建该属性，屏蔽原型属性使用delete操作符可以完全删除实例属性，从而可以重新访问到原型中的属性。 hasOwnProperty()方法可以检测一个属性是存在于实例中，还是存在于原型中。这个方法只在给定属性存在于对象实例中时，才会返回true。 123console.log(person1.hasOwnProperty(\"name\")) //false //实例中不存在person1.name=\"Greg\"; //\"Greg\" console.log(person1.hasOwnProperty(\"name\")) //true //来自实例 ECMAScript的Object.getOwnPropertyDescriptor()方法只能用于实例属性，要取得原型属性的描述符，必须之间在原型对象上调用Object.getOwnPropertyDescriptor()方法 原型与in操作符两种方式使用in操作符：单独使用和在for-in循环中使用单独使用时，in操作符会在通过对象能够访问给定属性时返回true，无论属性存在于实例中还是原型中。 123456789console.log(person1.hasOwnProperty(\"name\")); //fasle name存在于原型中console.log(\"name\" in person1) //true 原型中存在nameperson1.name=\"Greg\" //实例中存在nameconsole.log(person1.hasOwnProperty(\"name\")) //trueconsole.log(\"name\" in person1) //truedelete person1.name; //删除实例中nameconsole.log(person1.name) //\"Nich\" //原型 1234//判断属性存在于对象实例中还是原型中function hasPrototypeProperty(object,name)&#123; return !object.hasOwnProperty(name)&amp;&amp;(name in object);&#125; 在使用for-in循环时，返回的是所有能够通过对象访问的、可枚举的(enumerated)属性，其中既包括存在于实例中的属性，也包括原型中的属性。屏蔽了原型中的不可枚举属性(即将[[enumerable]]标记为false的属性)的实例属性也会在for-in循环中返回。因为所有开发人员定义的属性都是可枚举的不可枚举的属性和方法：hasOwnProperty()、propertyIsEnumerable()、toLocaleString()、toString()和valueOf()。ECMAScript5也将constructor和prototype属性的[[Enumerable]]特性设置为false。 可以使用ECMAScript5的Object.keys()方法来获取对象上所有可枚举的实例属性。这个方法接收一个对象作为参数，返回一个包含所有可枚举属性的字符串数组 Object.getOwnPropertyNames()可以返回所有实例属性，无论是否可枚举。以上两个方法可以替代for-in循环 更简单的原型语法使用包含所有属性和方法的对象字面量重写整个原型对象。 123456789function Person()&#123;&#125;Person.prototype=&#123; name:\"Nich\", age:29, job:\"ali\", sayName:function()&#123; console.log(this.name); &#125;&#125;; 问题：constructor属性不在指向Person,而指向Object构造函数，尽管instanceof操作符还能返回正确结果，但通过constructor已经无法确定对象的类型了 12345var fri=new Person();console.log(fri instanceof Object) //trueconsole.log(fri instanceof Person) //trueconsole.log(fri.constructor ==Person) //falseconsole.log(fri.constructor ==Object) //true 可以手动给Person.prototype添加一个construcotr属性 12345Person.prototype=&#123; constructor:Person, ...&#125;//手动重设constructor属性会导致它的[[Enumerable]] 特性被设置为true，但默认是不可枚举的 ECMAScript5可以使用Object.defineProperty() 123456//重设构造函数，只适用于ECMAScript5兼容的浏览器Object.defineProperty(Person.prototype,\"constructor\",&#123; enumerable:false, value:Person&#125;); 原型的动态性由于在原型上的查找值的过程是一次搜索，因此我们对原型对象所做的任何修改都能够立即从实例上反应出来—即使是先创建了实例后修改原型也如此 12345678var f=new Person();Person.prototype.sayHi=function()&#123; alert(\"hi\");&#125;f.sayHi(); //\"hi\"//先创建了一个Person的实例，而后在Person原型中添加方法，即使先创建实例在添加方法前执行，仍可访问方法//因为实例与原型之间的连接只不过是一个指针，而非一个副本，因此就可以在原型中找到新的sayHi属性并返回保存在那里的函数。//若重写了原型对象，就和前面情况不一样了 请注意，实例中的指针仅指向原型，而不指向构造函数。1234567891011function Person()&#123;&#125;var f=new Person();Person.prototype=&#123; constructor:Person, .. sayName:function()&#123; console.log(this.name) &#125;&#125;;f.sayName(); //error//因为f指向的原型中不包含以该名字命名的属性 由图可以看出，重写原型对象切断了现有原型与任何之前已经存在的对象实例之间的联系。它们引用的仍然是最初的原型。 原生对象的原型所有原生的引用类型(Object,Array,String,等等)都在其构造函数的原型上定义了方法。如，在Array.prototype中可以找到sort()方法,而在String.prototype中可以找到substring()方法， 通过原生对象的原型，不仅可以取得所有默认方法的引用，而且也可以定义新方法。可以像修改自定义对象的原型一样修改原生对象的原型，可以随时添加方法。 123456//给String添加了一个名为startsWith()的方法String.prototype.startsWith=function (text)&#123; return this.indexOf(text)==0;&#125;;var msg=\"hello world\";console.log(msg.startsWith(\"hello\"))//true 原型对象的问题原型模式省略了给构造函数传递参数的环节，导致所有实例在默认情况下都会得到相同属性值原型中的所有属性被实例共享，对于基本类型在属性，没什么问题，但对于引用类型值的属性，问题就突出修改一个实例中的某个引用类型值后，另一个实例中的引用类型值也会修改。 组合使用构造函数模式和原型模式构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性。 1234567891011121314151617181920function Person(name,age,job)&#123; this.name=name; this.age=age; this.job=job; this.friends=[\"shelby\",\"court\"];&#125;Person.prototype=&#123; constructor:Person, sayName:function()&#123; console.log(this.name); &#125;&#125;var person1=new Person(\"nich\",29,\"software\");var person2=new Person(\"greg\",27,\"doctor\");person1.friends.push(\"van\");console.log(person1.friends); //\"shelby,court,van\"console.log(person2.friends); //\"shelby,court\"console.log(person1.friends==person2.friends); //falseconsole.log(person1.sayName==person2.sayName); //true 这种构造函数与原型混成的模式，是目前ECMAScript中使用最广泛、认同度最高的一种创建自定义类型的方法。 动态原型模式动态原型模式将所有信息封装在构造函数中，通过构造函数初始化原型(仅在必要情况下),保持了构造函数和原型的优点 123456789101112131415function Person(name,age,job)&#123; //属性 this.name=name; this.age=age; this.job=job; //方法 //通过判断方法是否存在，来初始化原型，还可以使用instanceof操作符判断类型 if(typeof this.sayName!=\"function\")&#123; Person.prototype.sayName=function()&#123; console.log(this.name); &#125;; &#125;&#125;var f=new Person(\"nich\",30,\"soft\");f.sayName(); 使用动态原型模式时，不能使用对象字面量重写原型。若重写，就会切断现有实例与新原型之间的联系。 寄生构造函数模式寄生构造函数模式思想是创建一个函数，该函数作用仅仅是封装创建对象的代码并返回对象 12345678910function Person(name,age,job)&#123; var o=new Object(); o.name=name; o.sayName=function()&#123; console.log(this.name); &#125; return o;&#125;var f=new Person(\"nich\",30,\"ali\");f.sayName(); //\"nich\" 除了使用new操作符创建对象并把使用的包装函数叫做构造函数外，其他和工厂模式一样构造函数在不返回值的情况下，会默认返回新对象实例。在构造函数末尾加return，可以重写调用构造函数时返回的值 可以在特殊情况下为对象创建构造函数。创建一个具有额外方法的数组。由于不能之间修改Array构造函数，可以使用该模式 1234567891011121314function SpecialArray()&#123; //创建数组 var values=new Array(); //添加值 values.push.apply(values,arguments); //把values.push方法作用域改为values实例上，传入arguments参数 //添加方法 values.toPipedString=function()&#123; return this.join(\"|\"); &#125; return values;&#125;var colors=new SpecialArray(\"red\",\"blue\");console.log(colors.toPipedString()) //\"red|blue\" 关于寄生构造函数模式，首先，返回的对象与构造函数或者构造函数的原型属性之间没有关系。也就是说，构造函数返回的对象与在构造函数外部创建的对象没有什么不同。所以不能依赖instanceof操作符来确定对象类型。所以，可以使用其他模式的情况下，不要使用这种模式。 稳妥构造函数模式稳妥对象就是没有公共属性，而且其方法也不引用this对象。稳妥对象最适合在一些安全环境中（禁止使用this和new），或防止数据被其他应用程序改动时使用。稳妥模式与寄生模式类似。有两点不同，一是新创建对象的实例方法不引用this，二是不使用new操作符调用构造函数。 1234567891011function Person(name,age,job)&#123; //创建要返回的对象 var o=new Object(); //可以在这里定义私有变量和函数 //添加方法 o.sayName=function()&#123; console.log(name); &#125; return o;&#125; 这种模式只能通过sayName方法访问name值，即使有其他代码给这个对象添加方法或数据成员，也不能通过其他方法访问name值与寄生模式类似，使用稳妥构造函数模式创建的对象与构造函数之间没什么关系，instanceof对这种对象没意义","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"},{"name":"js高级程序设计","slug":"js高级程序设计","permalink":"http://yoursite.com/tags/js%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"每日算法01","date":"2020-07-25T04:44:36.000Z","path":"2020/07/25/每日算法01/","text":"剪绳子给你一根长度为n的绳子，请把绳子剪成整数长的m段(m、n都是整数，n&gt;1并且m&gt;1,m&lt;=n),每段绳子的长度记为k[1],…k[m]。请问k[1]…k[m]可能的最大乘积是多少？ 例如，当绳子的长度为8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18. 贪心法12345678910111213141516171819202122232425262728293031323334353637public int cutRope(int target)&#123; //4 2*2 //5 2*3 //6 3*3 //7 2*2*3 4*3 //8 2*3*3 //9 3*3*3 //10 2*2*3*3 4*3*3 //11 2*3*3*3 //由以上举的例子可以看出，最后情况只可能为2或3 //由3(n-3)&gt;=2(n-2)，可知当n=5时，等式相等，当n&gt;5时，应让3尽量的多。 if(target&lt;2)&#123; return 0; &#125; if(target==2)&#123; //由题知m&gt;1,所以2为1*1=1 return 1; &#125; if(target==3)&#123; //m&gt;1,所以3为2*1=1 return 2; &#125; if(target%3==0)&#123; //当绳子长刚好为3的倍数，则结果为3的（target/3）次幂 return (int)Math.pow(3,target/3); &#125;else if(target%3==1)&#123; //当绳子长对3取余刚好等于1时，可以多留出一个3，结果就为3的（target/3-1）次幂乘以4 return 4*(int)Math.pow(3,target/3-1); &#125;else&#123; //当绳子长对3取余刚好等于2时，留出2，结果就为3的（target/3）次幂乘以2 return 2*(int)Math.pow(3,target/3); &#125;&#125;public static void main(String[] args) &#123; System.out.println(cutRope(8));//18 System.out.println(cutRope(9));//27&#125; 动态规划法123456789101112131415161718192021222324252627282930313233//一个比较简单的动态规划//求问题最优解，该问题可以分成若干个子问题，子问题之间还有重叠的更小的子问题，考虑使用动态规划。//以自上而下分析，在长度为n的绳子剪下乘积为f(n),剪下i长度后，还剩n-i，即得公式//f(n)=max(f(i)*f(n-i))//为了避免重复计算子问题，以从下往上的顺序计算小问题的解并保存下来，在以此为基础求解更大问题。//每public int cutRope(int target)&#123; if(target&lt;2)&#123; return 0; &#125; if(target==2)&#123; return 1; &#125; if(target==3)&#123; return 2; &#125; int []dp=new int[target+1]; dp[1]=1; dp[2]=2; dp[3]=3;//1 2 3 都是不剪绳子，得到的乘积最大 int res=0;//记录每次剪完的最大值 for (int i=4;i&lt;=target;i++)&#123; for (int j=1;j&lt;=i/2;j++)&#123;//要计算j*i-j的最大值，所以只用计算j&lt;=i的值 res=Math.max(res,dp[j]*dp[i-j]);//得到长度为i时，所有剪法的最大值 &#125; dp[i]=res;//得到当前剪法的最大值，保存到dp数组中 &#125; return dp[target];//返回最大值&#125;public static void main(String[] args) &#123; System.out.println(cutRope(8));//18 System.out.println(cutRope(9));//27&#125; sdfsfs","tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"贪心法","slug":"贪心法","permalink":"http://yoursite.com/tags/%E8%B4%AA%E5%BF%83%E6%B3%95/"},{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"js复习","date":"2020-07-25T00:44:37.000Z","path":"2020/07/25/js复习/","text":"RegExp类型ECMAScript通过RegExp类型来支持正则表达式 1var express=/ pattern / flags; 正则表达式的匹配模式支持下列3个标志123g:表示全局（global）模式，即模式被应用于所有字符串，而不是在遇到第一个匹配项立即停止i：表示不区分大小写（case-insensitive)模式m：表示多行（multiline）模式，即在一行到达文本末尾时还会继续查找下一行 模式中使用的所有元字符都必须转义，元字符包括1( [ &#123; \\ ^ $ | ? * + .&#125; ] ) 创建正则表达式两种方式字面量模式： 1var pattern1=/[bc]at/i; RegExp构造函数模式：接收两个参数，一个是匹配的字符串模式，一个是可选的标志字符串 1var pattern2=new RegExp(\"[bc]at\",\"i\"); 在ECMAScript3中，字面量模式始终会共享一个RegExp实例，而使用构造函数创建的每一个新RegExp实例都是一个新实例，在ECMAScript5中明确字面量修改为每次都创建RegExp实例 12345678910var re=null, i;for(i=0;i&lt;10;i++)&#123; re=/cat/g; console.log(re.test(\"catastrophe\"));&#125;for(i=0;i&lt;10;i++)&#123; re=new RegExp(\"cat\",\"g\"); console.log(re.test(\"catastrophe\"));&#125; RegExp实例属性12345global:布尔值，表示是否设置了g标志ignoreCase:布尔值，表示是否设置了i标志lastIndex:整数，表示开始搜索下一个匹配项的字符位置，从0算起multiline：布尔值，表示是否设置了m标志source：正则表达式的字符串表示，按照字面量形式而非传入构造函数中的字符串模式返回 RegExp实例方法捕获组：把正则表达式中子表达式匹配的结果，分组按顺序保存，之后可以通过序号或名称来使用这些内容。目前，js只能通过序号访问。 RegExp对象的主要方法为exec()，该方法主要为捕获组，接收一个要应用模式的字符串，返回包含第一个匹配项信息的数组，返回的数组为Array的实例，包含额外的两个属性：index和input，index表示匹配项在字符串中的位置，input表示应用正则表达式的字符串。 123456789var text=\"mom and dad and baby\";var pattern= /mom( and dad( and baby)?)?/gi;var matches=pattern.exec(text);console.log(matches.index) //0console.log(matches.input) //\"mom and dad and baby\"console.log(matches[0]) //\"mom and dad and baby\"console.log(matches[1]) //\"and dad and baby\"console.log(matches[2]) //\" and baby\" 对于exec()方法，在同一个字符串上调用多次exex()方法，若不设置g标志，每次都会返回第一个匹配项的信息，lastIndex始终保持不变，若设置了全局标志，每次都会在字符串中继续查找新的匹配项，lastIndex会变化。 RegExp中的另一个方法test()接收一个字符串参数。在模式与参数匹配情况下返回true，否则返回false。 123456var text=\"000-00-0000\";var pattern=/\\d&#123;3&#125;-\\d&#123;2&#125;-\\d&#123;4&#125;/;if(pattern.test(text))&#123; console.log(\"matched\");//matched&#125; RegExp实例继承的toLocaleString()和toString()方法都会返回正则表达式的字面量，与创建方式无关。正则表达式的valueOf()方法返回正则表达式本身。 RegExp构造函数属性这些属性适用于作用域中的所有正则表达式，并且给予所执行的最佳一次正则表达式操作而变化。 123456input 最近一次要匹配的字符串lastMatch 最近一次的匹配项lastParen 最近一次匹配的捕获组leftContext input字符串中lastMatch之前的文本multiline 布尔值，表示是否表达式都使用多行表示rightContext input字符串中lastMathch之后的文本 123456789101112131415var text=\"this has been a short summary\";var pattern=/(.)hort/g;/**opera不支持input lastmatch lastparen multiline*ie 不支持multiline*/if(pattern.test(text))&#123; console.log(RegExp.input); //this has been a short summary console.log(RegExp.leftContext); //this has been a console.log(RegExp.rightContext); //summary console.log(RegExp.lastMatch) //short console.log(RegExp.lastParen) //s console.log(RegExp.multiline) //false chrome中为undefined&#125; 除以上几个属性外，还要9个用于存储捕获组的构造函数属性，为RegExp.$1,RegExp.$2…RegExp.$9。调用exec()和test()时，这些属性会被自动填充。 模式的局限性ECMAScript中的正则表达式缺少了某些高级特性 1234567891.匹配字符串开始和结尾的\\A和\\Z锚2.向后查找3.并集和交集类4.原子组5.Unicode支持(单个字符除外，如\\uFFFF)6.命名的捕获组7.s(single,单行) 和x(free-spacing,无间隔) 匹配模式8.条件匹配9.正则表达式注释","tags":[{"name":"正则表达式","slug":"正则表达式","permalink":"http://yoursite.com/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"},{"name":"js高级程序设计","slug":"js高级程序设计","permalink":"http://yoursite.com/tags/js%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"第一篇博客","date":"2020-07-24T14:00:03.000Z","path":"2020/07/24/第一篇博客/","text":"大家好，我是一名计算机专业的学生。啥都不会，但啥都想学。这是我人生第一次写文章，我写文章的主要目的就是想把学习中遇到的知识点、问题及解决方案记录下来，方便以后随时可以拿来复习。写文章对自己来说也是一种记录成长的方式，见证自己的成长，不忘初心。希望大家多多提出一些意见，交流一下学习经验，希望结交更多的朋友，互相学习。自己的表达能力很欠缺，希望通过写文章可以提高自己的文章写作能力。后面我会分享的内容有前端、后端、数据库、算法与数据结构、面试题、设计模式、计算机基础、机器学习等一些学习资源。努力奋斗","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"}]}]